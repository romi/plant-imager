{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to PlantImager","text":"<p>For full documentation of the ROMI project visit docs.romi-project.eu.</p>"},{"location":"#about","title":"About","text":"<p>To be as clear as possible, we first define the following names: - PlantImager: hardware control of the ROMI 3D plant imager. - VirtualPlantImager: simulate the plant imager using LPY to generate virtual plants and Blender for rendering. We recommend using it inside a docker container.</p>"},{"location":"#getting-started-with-docker","title":"Getting started with Docker","text":"<p>We strongly recommend using the docker images to use this library.</p>"},{"location":"#plantimager-docker-image","title":"PlantImager docker image","text":""},{"location":"#pull-a-pre-built-image","title":"Pull a pre-built image","text":"<p>The simplest way to use the docker image is to pull the pre-built <code>roboticsmicrofarms/plantimager</code> docker image as follows: <pre><code>docker pull roboticsmicrofarms/plantimager:latest\n</code></pre></p>"},{"location":"#start-a-container","title":"Start a container","text":"<p>In the <code>docker/plantimager/</code> directory, you will also find a convenience script named <code>run.sh</code>. To get usage information, from the <code>plant-imager</code> repository root folder: <pre><code>./docker/plantimager/run.sh -h\n</code></pre></p> <p>For example, to generate a new plant scan dataset, here named <code>my_scan</code>, simply do: <pre><code>./docker/plantimager/run.sh \\\n  -c \"romi_run_task Scan /myapp/db/my_scan --config plant-imager/config/hardware_scan_rx0.toml\"\n</code></pre></p>"},{"location":"#virtualplantimager-docker-image","title":"VirtualPlantImager docker image","text":""},{"location":"#pull-a-pre-built-image_1","title":"Pull a pre-built image","text":"<p>The simplest way to use the docker image is to pull the pre-built <code>roboticsmicrofarms/virtualplantimager</code> docker image as follows: <pre><code>docker pull roboticsmicrofarms/virtualplantimager:latest\n</code></pre></p>"},{"location":"#start-a-container_1","title":"Start a container","text":"<p>In the <code>docker/virtualplantimager/</code> directory, you will also find a convenience script named <code>run.sh</code>. To get usage information, from the <code>plant-imager</code> repository root folder: <pre><code>./docker/virtualplantimager/run.sh -h\n</code></pre></p> <p>For example, to generate a new virtual plant scan dataset, named <code>vplant_test</code>, simply do: <pre><code>./docker/virtualplantimager/run.sh --test\n</code></pre></p>"},{"location":"rest_api/","title":"VirtualPlantImager REST API","text":"<p>The Python implementation is done in the <code>bin/romi_virtualplantimager.py</code> file, that is also used to start a Flask server.</p> <p>Hereafter we list the GET/POST requests that can be made and give some examples.</p>"},{"location":"rest_api/#rest-urls","title":"REST URLs","text":""},{"location":"rest_api/#objects","title":"Objects","text":"<ul> <li><code>/objects</code> (GET): retrieve the list of <code>obj</code> files in the data folder that can be loaded.</li> <li><code>/load_object/&lt;object_id&gt;</code> (GET) load the given object in the scene. Takes a translation vector as URL parameters (<code>dx</code>, <code>dy</code>, <code>dz</code>)</li> </ul>"},{"location":"rest_api/#classes","title":"Classes","text":"<ul> <li><code>/classes</code> (GET): retrieve the list of classes.</li> </ul>"},{"location":"rest_api/#backgrounds","title":"Backgrounds","text":"<ul> <li><code>/backgrounds</code> (GET): retrieve the list of <code>hdr</code> files in the <code>hdri</code> folder that can be loaded.</li> <li><code>/load_background/&lt;background_id&gt;</code> (GET) load the given background in the scene.</li> </ul>"},{"location":"rest_api/#camera","title":"Camera","text":"<ul> <li><code>/camera_intrinsics</code> (POST): set camera intrinsics. Keys: <code>width</code>, <code>height</code>, <code>focal</code></li> <li><code>/camera_pose</code> (POST): set camera pose. Keys: <code>tx</code>, <code>ty</code>, <code>tz</code>, <code>rx</code>, <code>ry</code>, <code>rz</code></li> </ul>"},{"location":"rest_api/#rendering","title":"Rendering","text":"<ul> <li><code>/render</code> (GET): gets the rendering of the scene</li> <li><code>/render_class/&lt;class_id&gt;</code> (GET) renders the scene, with everything transparent except the given class</li> </ul> <p>Todo</p> <p>Missing endpoints.</p>"},{"location":"rest_api/#examples","title":"Examples","text":"<p>Using a browser to send HTTP requests is not too convenient. Instead, you may use httpie to send HTTP commands from a terminal.</p> <p>To easily adapt to other configurations, we define the <code>$VPI_HOST</code> &amp; <code>$VPI_PORT</code> variables. For example, matching the example given above, we define: <pre><code>export VPI_HOST='172.17.0.2'\nexport VPI_PORT='9001'\n</code></pre></p>"},{"location":"rest_api/#setup-camera","title":"Setup camera","text":"<pre><code>http -f post \"http://$VPI_HOST:$VPI_PORT/camera_intrinsics width=1920 height=1080 focal=35\"\n</code></pre>"},{"location":"rest_api/#load-arabidopsis_0-obj","title":"Load <code>arabidopsis_0</code> OBJ","text":"<pre><code>http get \"http://$VPI_HOST:$VPI_PORT/load_object/arabidopsis_0.obj?dx=10&amp;dy=20&amp;dz=1\"\n</code></pre>"},{"location":"rest_api/#load-old-tree-in-the-park-background","title":"Load \"old tree in the park\" background","text":"<pre><code>http get \"http://127.0.0.1:$VPI_PORT/load_background/old_tree_in_city_park_8k.hdr\"\n</code></pre>"},{"location":"rest_api/#move-camera","title":"Move camera","text":"<pre><code>http -f post \"http://$VPI_HOST:$VPI_PORT/camera_pose tx=-60 ty=0 tz=50 rx=60 ry=0 rz=-90\"\n</code></pre>"},{"location":"rest_api/#render-scene-and-download-image","title":"Render scene and download image","text":"<pre><code>http --download get \"http://$VPI_HOST:$VPI_PORT/render\"\n</code></pre>"},{"location":"rest_api/#render-only-leaves","title":"Render only leaves","text":"<pre><code>http --download get \"http://$VPI_HOST:$VPI_PORT/render_class/Color_7\"\n</code></pre>"},{"location":"developer/","title":"Developers","text":"<p>Developers instructions:</p> <ul> <li>about this documentation</li> <li>specifications for the VirtualPlantImager</li> </ul>"},{"location":"developer/documentation/","title":"Building the documentation","text":"<p>We use <code>mkdocs</code> to build the documentation with <code>mkdocs-material</code> theme. The API documentation is generated by <code>mkdocstrings</code>. Also, we use <code>markdown-exec</code> to execute some code snippets to generate output parsed in Markdown. Finally, you may want to check the <code>pymdown-extensions</code> documentation.</p>"},{"location":"developer/documentation/#requirements","title":"Requirements","text":"<p>To install the requirements for documentation edition, simply run: <pre><code>python -m pip install -e .[doc]\n</code></pre></p>"},{"location":"developer/documentation/#live-edit","title":"Live edit","text":"<p>You can edit the documentation, <code>mkdocs.yaml</code> and the <code>docs</code> directory, and see the changes live by using: <pre><code>mkdocs serve\n</code></pre></p> <p>You should see some logging and this message, indicating where to view it: <pre><code>INFO    -  [14:39:21] Serving on http://127.0.0.1:8000/\n</code></pre></p>"},{"location":"developer/documentation/#publish-online","title":"Publish online","text":"<p>The documentation is published online thanks to a CI job defined in the <code>.github/workflows/gh-pages.yml</code> file.</p>"},{"location":"developer/virtualplantimager/","title":"VirtualPlantImager specifications","text":""},{"location":"developer/virtualplantimager/#start-the-blender-server","title":"Start the Blender server","text":"<p>There are many ways to do this, but the simplest &amp; fastest option is to use the Docker image <code>roboticsmicrofarms/virtualplantimager</code>.</p> <p>Note</p> <p>We make use of the <code>$ROMI_DB</code> environment variable. If not done yet, you may want to set it with <code>export ROMI_DB=/path/to/database</code>. Or replace it with the path to use.</p>"},{"location":"developer/virtualplantimager/#1-start-a-container","title":"1. Start a container","text":"Docker CLI<code>run.sh</code> script <p>Start a container and open a bash shell: <pre><code>docker run -it --gpus all roboticsmicrofarms/virtualplantimager:latest -v $ROMI_DB:/myapp/db bash\n</code></pre></p> <p>Start a container and open a bash shell: <pre><code>./docker/virtualplantimager/run.sh -db $ROMI_DB\n</code></pre></p>"},{"location":"developer/virtualplantimager/#2-start-the-blender-flask-server","title":"2. Start the Blender Flask server","text":"<p>Then start the Blender server (listening to port <code>9001</code>) with: <pre><code>romi_bpy plant-imager/bin/romi_virtualplantimager -- --port 9001\n</code></pre></p> <p>When the server is up and running you should get something like: <pre><code> * Serving Flask app 'romi_virtualplantimager'\n * Running on all addresses (0.0.0.0)\n * Running on http://127.0.0.1:9001\n * Running on http://172.17.0.2:9001\n</code></pre></p> <p>Note</p> <p>The first HTTP address is accessible from within the container. The second HTTP address is accessible from the host running the container.</p>"},{"location":"developer/virtualplantimager/#test-the-server","title":"Test the server","text":"From the hostFrom the container <p>You may now use a web browser to submit a <code>/hello_world</code> request at <code>http://172.17.0.2:9001</code>.</p> <p>To do so, just copy/paste <code>http://172.17.0.2:9001/hello_world</code> to the URL bar.</p> <p>You may use Python to submit a request at <code>http://172.0.0.1:9001</code>.</p> <p>For example, you may get info by submitting a <code>/hello_world</code> request as follows:</p> <ol> <li>Open a new shell in the running container with (do not forget to replace the <code>CONTAINER_ID</code>): <pre><code>docker exec -it CONTAINER_ID bash\n</code></pre></li> <li>Then use Python to send a GET request: <pre><code>python -c \"import requests\nres = requests.get('http://127.0.0.1:9001/hello_world')\nprint(res.content.decode())\"\n</code></pre></li> </ol> <p>You should get a JSON response similar to this: <pre><code>\"Hello World!\"\n\"I am a Flask server named 'romi_virtualplantimager'.\"\n\"I run Blender 2.93.16 built on 2023-03-21.\"\n\"I run Python 3.9.16.\"\n</code></pre></p>"},{"location":"docker/","title":"Docker","text":"<p>Docker instructions:</p> <ul> <li>VirtualPlantImager</li> </ul>"},{"location":"docker/virtualplantimager/","title":"Docker for VirtualPlantImager","text":""},{"location":"docker/virtualplantimager/#prerequisites","title":"Prerequisites","text":"<p>Follow the getting started with docker instructions to install the required software.</p> <p>Important</p> <p>We advise to assign an existing local database directory to <code>$ROMI_DB</code>, it will be mounted at container startup. To see how to create a local database directory, look here.</p>"},{"location":"docker/virtualplantimager/#start-a-container","title":"Start a container","text":"<p>Assuming you have a valid ROMI database directory under <code>/data/ROMI/DB</code>, you can easily download and start the pre-built <code>roboticsmicrofarms/plantimager</code> docker image with one of the following command:</p> run.sh &amp; <code>ROMI_DB</code>run.sh &amp; <code>-db</code>docker run <p>From the root directory of the repository, use the convenience <code>run.sh</code> script: <pre><code>export ROMI_DB=/data/ROMI/DB\n./docker/run.sh\n</code></pre></p> <p>From the root directory of the repository, use the convenience <code>run.sh</code> script: <pre><code>./docker/run.sh -db /data/ROMI/DB\n</code></pre></p> <p>From any directory, use the <code>docker run</code> command as follows: <pre><code>export ROMI_DB=/data/ROMI/DB\ndocker run --runtime=nvidia --gpus all \\\n--env PYOPENCL_CTX='0' \\\n-v $ROMI_DB:/myapp/db \\\n-it roboticsmicrofarms/plantimager:latest\n</code></pre></p> <p>This should start the latest pre-built <code>roboticsmicrofarms/plantimager</code> docker image in interactive mode. The database location inside the docker container is <code>/myapp/db</code>.</p> <p>Note</p> <ul> <li><code>-v $ROMI_DB:/myapp/db</code> performs a bind mount to enable access to the local database by the docker image. See the official documentation.</li> <li>Use <code>./docker/run.sh -h</code> to get all details about how to use it.</li> </ul>"},{"location":"docker/virtualplantimager/#build-a-docker-image","title":"Build a docker image","text":"<p>If you do not wish to use one of the <code>roboticsmicrofarms/plantimager</code> pre-built image, you may build an image using the <code>docker/Dockerfile</code> recipe accessible in the repository of <code>plantimager</code>.</p> <p>We provide a convenience bash script to ease the build of <code>roboticsmicrofarms/plantimager</code> docker image. You can choose to use this script OR to \"manually\" call the <code>docker build</code> command.</p> build.shdocker build <p>From the root directory of the repository, use the convenience <code>build.sh</code> script: <pre><code>./docker/build.sh\n</code></pre></p> <p>From the root directory of the repository, use the <code>docker build</code> command as follows: <pre><code>export VTAG=\"latest\"\ndocker build -t roboticsmicrofarms/plantimager:$VTAG .\n</code></pre></p> <p>Tips</p> <ul> <li>By default, the image tag is 'latest', you can change it, e.g. to 'dev' with <code>-t dev</code>.</li> <li>Use <code>./docker/build.sh -h</code> to get all details about how to use it.</li> </ul> <p>You may want to clean the build cache, at least from time to time, with: <pre><code>docker builder prune -a\n</code></pre></p>"},{"location":"docker/virtualplantimager/#publish-docker-image","title":"Publish docker image","text":"<p>To push a newly built image on docker hub:</p> <pre><code>export VTAG=\"latest\"\ndocker push roboticsmicrofarms/plantdb:$VTAG\n</code></pre> <p>This requires a valid account &amp; token on dockerhub!</p>"},{"location":"docker/virtualplantimager/#example-usage","title":"Example usage","text":""},{"location":"docker/virtualplantimager/#test","title":"Test","text":"<p>You can test the creation of a virtual plant and its acquisition by the virtual scanner as follows:</p> <pre><code>./docker/run.sh --test\n</code></pre>"},{"location":"docker/virtualplantimager/#executing-a-romi-task","title":"Executing a ROMI task","text":"<p>To call a ROMI task, as defined in the <code>romitask</code> library, you should use the <code>romi_run_task</code> CLI.</p> <p>For example to create a virtual plant and acquire it with the <code>VirtualScanner</code>, as <code>&lt;my_vscan&gt;</code>, using the Blender server , you may use the following command: <pre><code>romi_run_task VirtualScan \\\n  /myapp/db/&lt;my_scan&gt;/ \\\n  --config plant-imager/configs/vscan_lpy_blender.toml\n</code></pre></p> <p>Important</p> <p>The previous command rely on the presence of a <code>vscan_data</code> directory, as it contains the LPY model, background and textures to use (as defined by the TOML configuration file).  It is accessible in the repository under <code>plant-imager/database_example/vscan_data</code>.</p>"},{"location":"docker/virtualplantimager/#toml-config","title":"TOML config","text":"<p>Todo</p> <p>The following subsections need to be reviewed!</p>"},{"location":"docker/virtualplantimager/#virtualplant","title":"VirtualPlant","text":"<p>To generate a virtual plant using LPY, the default configuration is as follows: <pre><code>[VirtualPlant]\nlpy_file_id = \"arabidopsis_notex\"\n\n[VirtualPlant.lpy_globals]\nBRANCHON = false\nMEAN_NB_DAYS = 40\nSTDEV_NB_DAYS = 5\nBETA = 51\nINTERNODE_LENGTH = 1.3\nSTEM_DIAMETER = 0.25\n</code></pre></p>"},{"location":"docker/virtualplantimager/#virtualscan","title":"VirtualScan","text":"<p>To perform a scan of a virtual plant, the default configuration is as follows: <pre><code>[PaletteFileset]\nscan_id = \"vscan_data\"\n\n[HdriFileset]\nscan_id = \"vscan_data\"\n\n[LpyFileset]\nscan_id = \"vscan_data\"\n\n[ScanPath.kwargs]\ncenter_x = 0\ncenter_y = 0\nz = 32\ntilt = 3\nradius = 40\nn_points = 36\n\n[ScanPath]\nclass_name = \"Circle\"\n\n[VirtualScan]\nload_scene = false\nscene_file_id = \"\"\nuse_palette = true\nuse_hdri = true\nobj_fileset = \"VirtualPlant\"\nhdri_fileset = \"HdriFileset\"\nscene_fileset = \"SceneFileset\"\npalette_fileset = \"PaletteFileset\"\nrender_ground_truth = true\ncolorize = true\n\n[VirtualScan.scanner]\nwidth = 1440\nheight = 1080\nfocal = 16\nflash = false\nport = 9001\nadd_leaf_displacement = true\n</code></pre></p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>plantimager<ul> <li>blender</li> <li>blgimbal</li> <li>cli<ul> <li>generate_dataset</li> <li>hardware_robustness</li> <li>multi_scan</li> </ul> </li> <li>configs<ul> <li>lpy</li> <li>scan</li> </ul> </li> <li>dummy</li> <li>dynamixel</li> <li>error</li> <li>gp2</li> <li>grbl</li> <li>hal</li> <li>log</li> <li>lpy</li> <li>path</li> <li>scanner</li> <li>sony</li> <li>tasks<ul> <li>lpy</li> <li>scan</li> </ul> </li> <li>units</li> <li>urlcam</li> <li>utils</li> <li>vscan</li> </ul> </li> </ul>"},{"location":"reference/plantimager/","title":"plantimager","text":""},{"location":"reference/plantimager/blender/","title":"blender","text":""},{"location":"reference/plantimager/blender/#plantimager.blender.check_engine","title":"<code>check_engine(engine='CYCLES')</code>","text":"<p>Check the rendering engine.</p> <p>Parameters:</p> Name Type Description Default <code>engine</code> <code>(CYCLES, BLENDER_EEVEE, BLENDER_WORKBENCH)</code> <p>The name of the rendering engine to use. Defaults to <code>CYCLES</code>.</p> <code>\"CYCLES\"</code> Source code in <code>plantimager/blender.py</code> <pre><code>def check_engine(engine=\"CYCLES\"):\n    \"\"\"Check the rendering engine.\n\n    Parameters\n    ----------\n    engine : {\"CYCLES\", \"BLENDER_EEVEE\", \"BLENDER_WORKBENCH\"}, optional\n        The name of the rendering engine to use.\n        Defaults to ``CYCLES``.\n    \"\"\"\n    engine = engine.upper()\n    try:\n        assert bpy.context.scene.render.engine == engine\n    except AssertionError:\n        logger.warning(f\"The selected engine is not '{engine}', it is '{bpy.context.scene.render.engine}'!\")\n    return\n</code></pre>"},{"location":"reference/plantimager/blender/#plantimager.blender.clean_mesh","title":"<code>clean_mesh(fname, out)</code>","text":"<p>Mesh cleaning function.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>The file path to the mesh object to load in Blender.</p> required <code>out</code> <code>str</code> <p>The file path to us to export the cleaned mesh object.</p> required Source code in <code>plantimager/blender.py</code> <pre><code>def clean_mesh(fname, out):\n    \"\"\"Mesh cleaning function.\n\n    Parameters\n    ----------\n    fname : str\n        The file path to the mesh object to load in Blender.\n    out : str\n        The file path to us to export the cleaned mesh object.\n    \"\"\"\n    check_engine()\n    log = _get_log_filepath(fname)\n    load_obj(fname, log=log)\n\n    def _clean_obj(out):\n        bpy.ops.object.select_all(action='SELECT')\n        bpy.ops.object.mode_set(mode='EDIT')\n        bpy.ops.mesh.select_all(action='SELECT')\n        # Remove vertices that are too close:\n        bpy.ops.mesh.remove_doubles(threshold=0.01)\n        # Close any hole in the mesh:\n        bpy.ops.mesh.fill_holes(0)\n        bpy.ops.mesh.set_normals_from_faces()\n        # Export the mesh:\n        bpy.ops.export_scene.obj(filepath=out)\n\n    # Redirect blender outputs to a log file:\n    with open(log, mode=\"a\") as f:\n        with redirect_stdout(f), redirect_stderr(f):\n            _clean_obj(out)\n\n    return\n</code></pre>"},{"location":"reference/plantimager/blender/#plantimager.blender.load_obj","title":"<code>load_obj(fname, log=None)</code>","text":"<p>Load a mesh in Blender.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>The file path to the mesh object to load in Blender.</p> required <code>log</code> <code>str</code> <p>The blender log file path.</p> <code>None</code> Source code in <code>plantimager/blender.py</code> <pre><code>def load_obj(fname, log=None):\n    \"\"\"Load a mesh in Blender.\n\n    Parameters\n    ----------\n    fname : str\n        The file path to the mesh object to load in Blender.\n    log : str, optional\n        The blender log file path.\n    \"\"\"\n    if log is None:\n        log = _get_log_filepath(fname)\n\n    def _clean_scene():\n        # Start by selecting all objects from initialized scene (with a cube) and remove them all:\n        bpy.ops.object.select_all(action='SELECT')\n        bpy.ops.object.delete()\n\n    def _open_obj(fname):\n        # Load the mesh in Blender:\n        bpy.ops.import_scene.obj(filepath=fname)\n\n    with open(log, mode=\"a\") as f:\n        # Redirect blender outputs to a log file:\n        with redirect_stdout(f), redirect_stderr(f):\n            _clean_scene()\n            _open_obj(fname)\n\n    # List all imported objects &amp; set them as active:\n    o = bpy.data.objects[list(bpy.data.objects.keys())[0]]\n    bpy.context.view_layer.objects.active = o\n    return\n</code></pre>"},{"location":"reference/plantimager/blender/#plantimager.blender.split_by_material","title":"<code>split_by_material(fname, out, material_class_corres)</code>","text":"<p>Mesh splitting function.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>The file path to the mesh object to load in Blender.</p> required <code>out</code> <code>str</code> <p>The file path to us to export the cleaned mesh object.</p> required <code>material_class_corres</code> <code>dict</code> <p>A renaming dictionary, map LPY class names to semantic class names.</p> required Source code in <code>plantimager/blender.py</code> <pre><code>def split_by_material(fname, out, material_class_corres):\n    \"\"\"Mesh splitting function.\n\n    Parameters\n    ----------\n    fname : str\n        The file path to the mesh object to load in Blender.\n    out : str\n        The file path to us to export the cleaned mesh object.\n    material_class_corres : dict\n        A renaming dictionary, map LPY class names to semantic class names.\n    \"\"\"\n    check_engine()\n    log = _get_log_filepath(fname)\n    load_obj(fname, log=log)\n\n    bpy.ops.object.mode_set(mode='EDIT')\n    bpy.ops.mesh.select_all(action='SELECT')\n    bpy.ops.mesh.separate(type='MATERIAL')\n    bpy.ops.object.mode_set(mode='OBJECT')\n\n    # After separating, all pieces are selected and named accordingly:\n    for o in bpy.context.selected_objects:\n        # Remove x rotation from LPY\n        o.rotation_euler[0] = 0\n        # Rename object by the material applied to it\n        if o.active_material.name in material_class_corres:\n            class_name = material_class_corres[o.active_material.name]\n            o.name = class_name\n            o.active_material.name = class_name\n        else:\n            o.name = o.active_material.name\n\n    # Export the mesh:\n    with open(log, mode=\"a\") as f:\n        with redirect_stdout(f), redirect_stderr(f):\n            bpy.ops.export_scene.obj(filepath=out)\n\n    return\n</code></pre>"},{"location":"reference/plantimager/blgimbal/","title":"blgimbal","text":"<p>Implementation of a class dedicated to controlling a gimbal.</p> <p>This gimbal implementation is based on a custom-built controller. The gimbal is used to orient a camera by controlling pan &amp; tilt orientations. The control is done by a serial port that has to be defined.</p> <p>Note that this module offer the ability to use one or two motors. With one, you control the pan orientation, this is like turning your head left or right. With two, you can also control the tilt, this is like looking up or down. In conjunction with a 3-axis CNC, that gives a total of 5 degrees of freedom and thus the ability to scan the whole volume around the plant.</p>"},{"location":"reference/plantimager/blgimbal/#plantimager.blgimbal.Gimbal","title":"<code>Gimbal(port='/dev/ttyUSB0', baudrate=115200, has_tilt=True, steps_per_turn=360, zero_pan=0, zero_tilt=0, invert_rotation=False)</code>","text":"<p>             Bases: <code>AbstractGimbal</code></p> <p>Custom-built gimbal controller based on Feather M0 and a .</p> <p>Attributes:</p> Name Type Description <code>port</code> <code>str</code> <p>Serial port to use for communication with the Gimbal controller (Feather M0).</p> <code>baudrate</code> <code>(int, optional)</code> <p>Communication baud rate, <code>115200</code> should work with the Feather M0.</p> <code>status</code> <code>str</code> <p>Describe the gimbal current status, \"idle\" or \"moving\".</p> <code>p</code> <code>[float, float]</code> <p>Current pan and tilt positions.</p> <code>serial_port</code> <code>Serial</code> <p>The <code>Serial</code> instance used to send commands to the gimbal.</p> <code>zero_pan</code> <code>float</code> <p>The angle, in degree, to use as zero for pan.</p> <code>zero_tilt</code> <code>float</code> <p>The angle, in degree, to use as zero for tilt.</p> <code>has_tilt</code> <code>bool</code> <p>Indicate if the gimbal has a tilt motor or just a pan motor.</p> <code>steps_per_turn</code> <code>int</code> <p>Number of steps required to complete a full rotation.</p> <code>invert_rotation</code> <code>bool</code> <p>Use it to invert the rotation of the motor.</p> See Also <p>plantimager.hal.AbstractGimbal</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from plantimager.blgimbal import Gimbal\n&gt;&gt;&gt; g = Gimbal(\"Feather M0\", has_tilt=False, invert_rotation=True)\n&gt;&gt;&gt; g.status\n</code></pre> <p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>Serial port to use for communication with the Gimbal controller. This can also be a regular expression to identify in a unique way the corresponding port. Defaults to <code>\"/dev/ttyUSB0\"</code>.</p> <code>'/dev/ttyUSB0'</code> <code>baudrate</code> <code>int</code> <p>Communication baud rate, <code>115200</code> should work with the Feather M0.</p> <code>115200</code> <code>has_tilt</code> <code>bool</code> <p>Indicate if the Gimbal has a tilt motor. Defaults to <code>False</code>.</p> <code>True</code> <code>steps_per_turn</code> <code>int</code> <p>Indicate the number of steps to perform for a full revolution (360\u00b0). Defaults to <code>360</code>.</p> <code>360</code> <code>zero_pan</code> <code>float</code> <p>Indicate the origin position of the Gimbal for the pan-axis. Defaults to <code>0.</code>.</p> <code>0</code> <code>zero_tilt</code> <code>float</code> <p>Indicate the origin position of the Gimbal for the tilt-axis. Defaults to <code>0.</code>.</p> <code>0</code> <code>invert_rotation</code> <code>bool</code> <p>Indicate if rotation direction should be inverted. Defaults to <code>False</code>.</p> <code>False</code> Source code in <code>plantimager/blgimbal.py</code> <pre><code>def __init__(self, port=\"/dev/ttyUSB0\", baudrate=115200, has_tilt=True, steps_per_turn=360,\n             zero_pan=0, zero_tilt=0, invert_rotation=False):\n    \"\"\"Constructor.\n\n    Parameters\n    ----------\n    port : str, optional\n        Serial port to use for communication with the Gimbal controller.\n        This can also be a regular expression to identify in a unique way the corresponding port.\n        Defaults to `\"/dev/ttyUSB0\"`.\n    baudrate : int, optional\n        Communication baud rate, `115200` should work with the Feather M0.\n    has_tilt : bool, optional\n        Indicate if the Gimbal has a tilt motor.\n        Defaults to ``False``.\n    steps_per_turn : int, optional\n        Indicate the number of steps to perform for a full revolution (360\u00b0).\n        Defaults to ``360``.\n    zero_pan : float, optional\n        Indicate the origin position of the Gimbal for the pan-axis.\n        Defaults to ``0.``.\n    zero_tilt : float, optional\n        Indicate the origin position of the Gimbal for the tilt-axis.\n        Defaults to ``0.``.\n    invert_rotation : bool, optional\n        Indicate if rotation direction should be inverted.\n        Defaults to ``False``.\n\n    \"\"\"\n    super().__init__()\n    self.port = port if port.startswith('/dev') else guess_port(port)\n    self.baudrate = baudrate\n    self.status = \"idle\"\n    self.p = [0, 0]\n    self.serial_port = None\n    self.zero_pan = zero_pan\n    self.zero_tilt = zero_tilt\n    self.has_tilt = has_tilt\n    self.steps_per_turn = steps_per_turn\n    self.invert_rotation = invert_rotation\n    self.start()\n    atexit.register(self.stop)\n</code></pre>"},{"location":"reference/plantimager/blgimbal/#plantimager.blgimbal.Gimbal.__send","title":"<code>__send(s)</code>","text":"<p>Send a command trough the serial port.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The command to send to the custom board controlling the Gimbal.</p> required Source code in <code>plantimager/blgimbal.py</code> <pre><code>def __send(self, s):\n    \"\"\"Send a command trough the serial port.\n\n    Parameters\n    ----------\n    s : str\n        The command to send to the custom board controlling the Gimbal.\n    \"\"\"\n    if not self.serial_port:\n        raise Error(\"Serial connection to gimbal has not been started yet!\")\n    self.serial_port.reset_input_buffer()\n    r = False\n    try:\n        self.serial_port.write(bytes(f\"{s}\\n\", 'utf-8'))\n        time.sleep(0.01)\n        r = self.serial_port.readline()\n    finally:\n        pass  # dummy statement to avoid empty 'finally' clause\n    if r == False:\n        logger.critical(f\"Command failed: `{s}`!\")\n    return r\n</code></pre>"},{"location":"reference/plantimager/blgimbal/#plantimager.blgimbal.Gimbal.get_position","title":"<code>get_position()</code>","text":"<p>Returns the pan &amp; tilt positions of the Gimbal.</p> Source code in <code>plantimager/blgimbal.py</code> <pre><code>def get_position(self) -&gt; list:\n    \"\"\"Returns the pan &amp; tilt positions of the Gimbal.\"\"\"\n    self.update_status()\n    return self.p\n</code></pre>"},{"location":"reference/plantimager/blgimbal/#plantimager.blgimbal.Gimbal.get_status","title":"<code>get_status()</code>","text":"<p>Returns the status of the custom board controlling the Gimbal.</p> Source code in <code>plantimager/blgimbal.py</code> <pre><code>def get_status(self) -&gt; str:\n    \"\"\"Returns the status of the custom board controlling the Gimbal.\"\"\"\n    self.update_status()\n    return self.status\n</code></pre>"},{"location":"reference/plantimager/blgimbal/#plantimager.blgimbal.Gimbal.moveto","title":"<code>moveto(pan, tilt)</code>","text":"<p>Move to a target position for pan &amp; tilt.</p> <p>Parameters:</p> Name Type Description Default <code>pan</code> <code>float</code> <p>The desired <code>pan</code> orientation.</p> required <code>tilt</code> <code>float</code> <p>The desired <code>tilt</code> orientation.</p> required Source code in <code>plantimager/blgimbal.py</code> <pre><code>def moveto(self, pan, tilt):\n    \"\"\"Move to a target position for pan &amp; tilt.\n\n    Parameters\n    ----------\n    pan : float\n        The desired `pan` orientation.\n    tilt : float\n        The desired `tilt` orientation.\n    \"\"\"\n    self.moveto_async(pan, tilt)\n    self.wait()\n    return None\n</code></pre>"},{"location":"reference/plantimager/blgimbal/#plantimager.blgimbal.Gimbal.moveto_async","title":"<code>moveto_async(pan, tilt)</code>","text":"<p>Asynchronous move to a target position for pan &amp; tilt.</p> <p>Parameters:</p> Name Type Description Default <code>pan</code> <code>float</code> <p>The desired <code>pan</code> orientation.</p> required <code>tilt</code> <code>float</code> <p>The desired <code>tilt</code> orientation.</p> required Source code in <code>plantimager/blgimbal.py</code> <pre><code>def moveto_async(self, pan, tilt):\n    \"\"\"Asynchronous move to a target position for pan &amp; tilt.\n\n    Parameters\n    ----------\n    pan : float\n        The desired `pan` orientation.\n    tilt : float\n        The desired `tilt` orientation.\n    \"\"\"\n    self.set_target_pos(pan, tilt)\n    return None\n</code></pre>"},{"location":"reference/plantimager/blgimbal/#plantimager.blgimbal.Gimbal.set_target_pos","title":"<code>set_target_pos(pan, tilt)</code>","text":"<p>Set a target position for pan &amp; tilt.</p> <p>Parameters:</p> Name Type Description Default <code>pan</code> <code>float</code> <p>The desired <code>pan</code> orientation.</p> required <code>tilt</code> <code>float</code> <p>The desired <code>tilt</code> orientation.</p> required Source code in <code>plantimager/blgimbal.py</code> <pre><code>def set_target_pos(self, pan, tilt):\n    \"\"\"Set a target position for pan &amp; tilt.\n\n    Parameters\n    ----------\n    pan : float\n        The desired `pan` orientation.\n    tilt : float\n        The desired `tilt` orientation.\n    \"\"\"\n    if self.invert_rotation:\n        pan = -pan\n    self.__send(\"X%d\" % (self.zero_pan + int(pan / 360 * self.steps_per_turn)))\n    if self.has_tilt:\n        self.__send(\"Y%d\" % (self.zero_tilt + int(tilt / 360 * self.steps_per_turn)))\n    return None\n</code></pre>"},{"location":"reference/plantimager/blgimbal/#plantimager.blgimbal.Gimbal.start","title":"<code>start()</code>","text":"<p>Start the serial connection with the custom board controlling the Gimbal.</p> Source code in <code>plantimager/blgimbal.py</code> <pre><code>def start(self):\n    \"\"\"Start the serial connection with the custom board controlling the Gimbal.\"\"\"\n    self.serial_port = serial.Serial(self.port, self.baudrate, timeout=1, write_timeout=3)\n    self.update_status()\n    return None\n</code></pre>"},{"location":"reference/plantimager/blgimbal/#plantimager.blgimbal.Gimbal.stop","title":"<code>stop()</code>","text":"<p>Stop the serial connection with the custom board controlling the Gimbal.</p> Source code in <code>plantimager/blgimbal.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the serial connection with the custom board controlling the Gimbal.\"\"\"\n    if self.serial_port:\n        self.serial_port.close()\n        self.serial_port = None\n    return None\n</code></pre>"},{"location":"reference/plantimager/blgimbal/#plantimager.blgimbal.Gimbal.update_status","title":"<code>update_status()</code>","text":"<p>Update the pan &amp; tilt positions.</p> Source code in <code>plantimager/blgimbal.py</code> <pre><code>def update_status(self):\n    \"\"\"Update the pan &amp; tilt positions.\"\"\"\n    p = self.__send(\"p\").decode('utf-8')\n    logger.debug(f\"Raw gimbal response: {p}\")\n    p = p.split(\":\")[-1].split(\",\")\n    logger.debug(f\"Gimbal response: pan={p[0]}, tilt={p[1]}\")\n    self.p[0] = (int(p[0]) - self.zero_pan) / self.steps_per_turn * 360\n    self.p[1] = (int(p[1]) - self.zero_tilt) / self.steps_per_turn * 360\n    return None\n</code></pre>"},{"location":"reference/plantimager/dummy/","title":"dummy","text":"<p>The dummy module offers CNC, Gimbal &amp; Camera implementation</p>"},{"location":"reference/plantimager/dummy/#plantimager.dummy.CNC","title":"<code>CNC(homing=False, x_lims=[0.0, 100.0], y_lims=[0.0, 100.0], z_lims=[0.0, 30.0])</code>","text":"<p>             Bases: <code>AbstractCNC</code></p> <p>A dummy CNC for testing purposes.</p> <p>TODO: enable workspace origin offset, motor seed configuration,...</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>list</code> <p>The current <code>pan</code> and <code>tilt</code> positions of the gimbal.</p> <code>x_lims</code> <code>((int, int), optional)</code> <p>The allowed range of X-axis positions.</p> <code>y_lims</code> <code>((int, int), optional)</code> <p>The allowed range of Y-axis positions.</p> <code>z_lims</code> <code>((int, int), optional)</code> <p>The allowed range of Z-axis positions.</p> Example <p>from plantimager.dummy import CNC cnc = CNC() cnc.get_position() [80.5, 80.79, 15.46] cnc.home() cnc.get_position() [0.0, 0.0, 0.0] cnc.moveto(20, 20, 5) cnc.get_position() [20.0, 20.0, 5.0]</p> <p>Parameters:</p> Name Type Description Default <code>homing</code> <code>bool</code> <p>If <code>True</code>, axes homing will be performed upon CNC object instantiation.</p> <code>False</code> <code>x_lims</code> <code>(float, float)</code> <p>The allowed range of X-axis positions. Defaults to <code>[0., 100.]</code></p> <code>[0.0, 100.0]</code> <code>y_lims</code> <code>(float, float)</code> <p>The allowed range of Y-axis positions. Defaults to <code>[0., 100.]</code></p> <code>[0.0, 100.0]</code> <code>z_lims</code> <code>(float, float)</code> <p>The allowed range of Z-axis positions. Defaults to <code>[0., 30.]</code></p> <code>[0.0, 30.0]</code> Notes <p>If <code>homing</code> is false, a random initial position will be generated.</p> Source code in <code>plantimager/dummy.py</code> <pre><code>def __init__(self, homing=False, x_lims=[0., 100.], y_lims=[0., 100.], z_lims=[0., 30.]):\n    \"\"\"\n    Parameters\n    ----------\n    homing : bool, optional\n        If ``True``, axes homing will be performed upon CNC object instantiation.\n    x_lims : (float, float), optional\n        The allowed range of X-axis positions. Defaults to ``[0., 100.]``\n    y_lims : (float, float), optional\n        The allowed range of Y-axis positions. Defaults to ``[0., 100.]``\n    z_lims : (float, float), optional\n        The allowed range of Z-axis positions. Defaults to ``[0., 30.]``\n\n    Notes\n    -----\n    If `homing` is false, a random initial position will be generated.\n    \"\"\"\n    super().__init__()\n    self.x_lims = x_lims\n    self.y_lims = y_lims\n    self.z_lims = z_lims\n    self.position = self._random_position()\n    self.start(homing)\n</code></pre>"},{"location":"reference/plantimager/dummy/#plantimager.dummy.CNC.get_position","title":"<code>get_position()</code>","text":"<p>Returns the XYZ position of the CNC.</p> Source code in <code>plantimager/dummy.py</code> <pre><code>def get_position(self) -&gt; list:\n    \"\"\"Returns the XYZ position of the CNC.\"\"\"\n    return self.position\n</code></pre>"},{"location":"reference/plantimager/dummy/#plantimager.dummy.CNC.home","title":"<code>home()</code>","text":"<p>Performs axes homing procedure, setting axes position to their origin.</p> Source code in <code>plantimager/dummy.py</code> <pre><code>def home(self):\n    \"\"\"Performs axes homing procedure, setting axes position to their origin.\"\"\"\n    self.position = [0., 0., 0.]\n</code></pre>"},{"location":"reference/plantimager/dummy/#plantimager.dummy.CNC.moveto","title":"<code>moveto(x, y, z)</code>","text":"<p>Move axes to target XYZ position.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The target XYZ position, in millimeters.</p> required <code>y</code> <code>float</code> <p>The target XYZ position, in millimeters.</p> required <code>z</code> <code>float</code> <p>The target XYZ position, in millimeters.</p> required Source code in <code>plantimager/dummy.py</code> <pre><code>def moveto(self, x: float, y: float, z: float):\n    \"\"\"Move axes to target XYZ position.\n\n    Parameters\n    ----------\n    x, y, z : float\n        The target XYZ position, in millimeters.\n    \"\"\"\n    self.position[0] = float(x)\n    self.position[1] = float(y)\n    self.position[2] = float(z)\n    self.wait()\n</code></pre>"},{"location":"reference/plantimager/dummy/#plantimager.dummy.CNC.moveto_async","title":"<code>moveto_async(x, y, z)</code>","text":"<p>Move axes to target XYZ position.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The target XYZ position, in millimeters.</p> required <code>y</code> <code>float</code> <p>The target XYZ position, in millimeters.</p> required <code>z</code> <code>float</code> <p>The target XYZ position, in millimeters.</p> required Source code in <code>plantimager/dummy.py</code> <pre><code>def moveto_async(self, x: float, y: float, z: float):\n    \"\"\"Move axes to target XYZ position.\n\n    Parameters\n    ----------\n    x, y, z : float\n        The target XYZ position, in millimeters.\n    \"\"\"\n    self.position[0] = float(x)\n    self.position[1] = float(y)\n    self.position[2] = float(z)\n</code></pre>"},{"location":"reference/plantimager/dummy/#plantimager.dummy.CNC.start","title":"<code>start(homing=False)</code>","text":"<p>Start the CNC.</p> <p>Parameters:</p> Name Type Description Default <code>homing</code> <code>bool</code> <p>If <code>True</code>, performs homing procedure.</p> <code>False</code> Source code in <code>plantimager/dummy.py</code> <pre><code>def start(self, homing=False):\n    \"\"\"Start the CNC.\n\n    Parameters\n    ----------\n    homing : bool\n        If ``True``, performs homing procedure.\n    \"\"\"\n    if homing:\n        self.home()\n    else:\n        pass\n</code></pre>"},{"location":"reference/plantimager/dummy/#plantimager.dummy.Gimbal","title":"<code>Gimbal(homing=False, pan_lims=[0.0, 360.0], tilt_lims=[-90.0, 90.0])</code>","text":"<p>             Bases: <code>AbstractGimbal</code></p> <p>A dummy Gimbal for testing purposes.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>list</code> <p>The current <code>pan</code> and <code>tilt</code> positions of the gimbal.</p> <code>pan_lims</code> <code>((float, float), optional)</code> <p>The allowed range of pan-axis positions. Defaults to <code>[0., 360.]</code></p> <code>tilt_lims</code> <code>((float, float), optional)</code> <p>The allowed range of tilt-axis positions. Defaults to <code>[-90., 90.]</code></p> Example <p>from plantimager.dummy import Gimbal gimbal = Gimbal() gimbal.get_position() [289.8, 55.43] gimbal.moveto(90, 10) gimbal.get_position() [90.0, 10.0] gimbal.home() gimbal.get_position() [0.0, 0.0]</p> <p>Parameters:</p> Name Type Description Default <code>homing</code> <code>bool</code> <p>If <code>True</code>, axes homing will be performed upon CNC object instantiation.</p> <code>False</code> <code>pan_lims</code> <code>(float, float)</code> <p>The allowed range of pan-axis positions. Defaults to <code>[0., 360.]</code></p> <code>[0.0, 360.0]</code> <code>tilt_lims</code> <code>(float, float)</code> <p>The allowed range of tilt-axis positions. Defaults to <code>[-90., 90.]</code></p> <code>[-90.0, 90.0]</code> Notes <p>If <code>homing</code> is false, a random initial position will be generated.</p> Source code in <code>plantimager/dummy.py</code> <pre><code>def __init__(self, homing=False, pan_lims=[0., 360.], tilt_lims=[-90., 90.]):\n    \"\"\"\n    Parameters\n    ----------\n    homing : bool, optional\n        If ``True``, axes homing will be performed upon CNC object instantiation.\n    pan_lims : (float, float), optional\n        The allowed range of pan-axis positions. Defaults to ``[0., 360.]``\n    tilt_lims : (float, float), optional\n        The allowed range of tilt-axis positions. Defaults to ``[-90., 90.]``\n\n    Notes\n    -----\n    If `homing` is false, a random initial position will be generated.\n    \"\"\"\n    super().__init__()\n    self.pan_lims = pan_lims\n    self.tilt_lims = tilt_lims\n    self.position = self._random_position()\n    self.start(homing)\n</code></pre>"},{"location":"reference/plantimager/dummy/#plantimager.dummy.Gimbal.get_position","title":"<code>get_position()</code>","text":"<p>Returns the pan &amp; tilt position of the Gimbal.</p> Source code in <code>plantimager/dummy.py</code> <pre><code>def get_position(self) -&gt; list:\n    \"\"\"Returns the pan &amp; tilt position of the Gimbal.\"\"\"\n    return self.position\n</code></pre>"},{"location":"reference/plantimager/dummy/#plantimager.dummy.Gimbal.home","title":"<code>home()</code>","text":"<p>Performs axes homing procedure, setting axes position to their origin.</p> Source code in <code>plantimager/dummy.py</code> <pre><code>def home(self):\n    \"\"\"Performs axes homing procedure, setting axes position to their origin.\"\"\"\n    self.position = [0., 0.]\n    return\n</code></pre>"},{"location":"reference/plantimager/dummy/#plantimager.dummy.Gimbal.moveto","title":"<code>moveto(pan, tilt)</code>","text":"<p>Move the pan &amp; tilt axes to given position.</p> Source code in <code>plantimager/dummy.py</code> <pre><code>def moveto(self, pan: deg, tilt: deg):\n    \"\"\"Move the pan &amp; tilt axes to given position.\"\"\"\n    self.position[0] = float(pan)\n    self.position[1] = float(tilt)\n    self.wait()\n</code></pre>"},{"location":"reference/plantimager/dummy/#plantimager.dummy.Gimbal.moveto_async","title":"<code>moveto_async(pan, tilt)</code>","text":"<p>Move the pan &amp; tilt axes to given position.</p> Source code in <code>plantimager/dummy.py</code> <pre><code>def moveto_async(self, pan: deg, tilt: deg):\n    \"\"\"Move the pan &amp; tilt axes to given position.\"\"\"\n    self.position[0] = float(pan)\n    self.position[1] = float(tilt)\n    return\n</code></pre>"},{"location":"reference/plantimager/dummy/#plantimager.dummy.Gimbal.start","title":"<code>start(homing=False)</code>","text":"<p>Start the Gimbal.</p> <p>Parameters:</p> Name Type Description Default <code>homing</code> <code>bool</code> <p>If <code>True</code>, performs homing procedure.</p> <code>False</code> Source code in <code>plantimager/dummy.py</code> <pre><code>def start(self, homing=False):\n    \"\"\"Start the Gimbal.\n\n    Parameters\n    ----------\n    homing : bool\n        If ``True``, performs homing procedure.\n    \"\"\"\n    if homing:\n        self.home()\n    else:\n        pass\n    return\n</code></pre>"},{"location":"reference/plantimager/dummy/#plantimager.dummy.Gimbal.stop","title":"<code>stop()</code>","text":"<p>Stop the Gimbal.</p> Source code in <code>plantimager/dummy.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the Gimbal.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/plantimager/dynamixel/","title":"dynamixel","text":"<p>Implementation of a class dedicated to controlling a Gimbal.</p> <p>This Gimbal implementation is based on the Dynamixel xl430 SDK wrapping.</p>"},{"location":"reference/plantimager/dynamixel/#plantimager.dynamixel.Gimbal","title":"<code>Gimbal(dev='/dev/ttyUSB1', baud_rate=1000000, pan_id=1, tilt_id=2, pan0=0, tilt0=1024)</code>","text":"<p>             Bases: <code>AbstractGimbal</code></p> Source code in <code>plantimager/dynamixel.py</code> <pre><code>def __init__(self, dev: str = \"/dev/ttyUSB1\", baud_rate: int = 1000000,\n             pan_id: int = 1, tilt_id: int = 2, pan0: int = 0, tilt0: int = 1024):\n    self.baud_rate = baud_rate\n    self.dev = dev\n    self.port = xl430.USB2Dynamixel(dev)\n    self.port.start(baud_rate)  # Start USB serial connection\n    self.pan_zero = pan0\n    self.tilt_zero = tilt0\n    self.pan_id = pan_id\n    self.tilt_id = tilt_id\n    self.start()\n    atexit.register(self.stop)\n</code></pre>"},{"location":"reference/plantimager/dynamixel/#plantimager.dynamixel.Gimbal.moveto","title":"<code>moveto(pan, tilt)</code>","text":"<p>Move to given angles (in degrees)</p> Source code in <code>plantimager/dynamixel.py</code> <pre><code>def moveto(self, pan: deg, tilt: deg) -&gt; None:\n    \"\"\"\n    Move to given angles (in degrees)\n    \"\"\"\n    self.moveto_async(pan, tilt)\n    self.wait()\n</code></pre>"},{"location":"reference/plantimager/dynamixel/#plantimager.dynamixel.Gimbal.moveto_async","title":"<code>moveto_async(pan, tilt)</code>","text":"<p>Move to given angles (in degrees)</p> Source code in <code>plantimager/dynamixel.py</code> <pre><code>def moveto_async(self, pan: deg, tilt: deg) -&gt; None:\n    \"\"\"\n    Move to given angles (in degrees)\n    \"\"\"\n    pan = self.__pan_angle2steps(pan)\n    tilt = self.__tilt_angle2steps(tilt)\n    self.pan.set_goal_position(pan)\n    self.tilt.set_goal_position(tilt)\n</code></pre>"},{"location":"reference/plantimager/error/","title":"error","text":"<p>Custom errors module.</p>"},{"location":"reference/plantimager/error/#plantimager.error.Error","title":"<code>Error(message)</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for exceptions in this module.</p> Source code in <code>plantimager/error.py</code> <pre><code>def __init__(self, message):\n    self.message = message\n</code></pre>"},{"location":"reference/plantimager/gp2/","title":"gp2","text":"<p>Implementation of a camera module based on gPhoto2.</p> <p>Requires system library <code>libgphoto2-dev</code> &amp; python package <code>gphoto2</code>. <pre><code>sudo apt-get install libgphoto2-dev\npip install gphoto2\n</code></pre></p>"},{"location":"reference/plantimager/gp2/#plantimager.gp2.Camera","title":"<code>Camera()</code>","text":"<p>             Bases: <code>AbstractCamera</code></p> <p>gPhoto2 Camera object.</p> See Also <p>plantimager.hal.AbstractCamera</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from plantimager.gp2 import Camera\n&gt;&gt;&gt; cam = Camera()\n&gt;&gt;&gt; # Grab a picture as an hal.DataItem:\n&gt;&gt;&gt; img = cam.grab(0)\n&gt;&gt;&gt; # Get the numpy array with RGB data:\n&gt;&gt;&gt; arr = img.channel(\"rgb\").data\n&gt;&gt;&gt; arr.shape\n&gt;&gt;&gt; # Save the picture to a local file:\n&gt;&gt;&gt; img_file = cam.grab_write('gp2_img.jpg')\n</code></pre> Source code in <code>plantimager/gp2.py</code> <pre><code>def __init__(self):\n    self.camera = None\n    self.start()\n    atexit.register(self.stop)\n</code></pre>"},{"location":"reference/plantimager/gp2/#plantimager.gp2.Camera.grab","title":"<code>grab(idx, metadata=None)</code>","text":"<p>Grab a picture with gPhoto2.</p> Source code in <code>plantimager/gp2.py</code> <pre><code>def grab(self, idx: int, metadata: dict = None):\n    \"\"\"Grab a picture with gPhoto2. \"\"\"\n    # with tempfile.TemporaryDirectory as tmp:\n    #     fname = os.path.join(tmp, \"frame.jpg\")\n    #     self.grab_write(fname)\n    #     data_item = DataItem(idx, metadata)\n    #     data = imageio.imread(fname)\n    #     data_item.add_channel(\"rgb\", data)\n    #     return data_item\n    # Initialize an hal.DataItem object to return:\n    data_item = DataItem(idx, metadata)\n    # Capture\n    file_path = self.camera.capture(0)\n    camera_file = self.camera.file_get(file_path.folder, file_path.name, gp.GP_FILE_TYPE_NORMAL)\n    # Read data using 'get_data_and_size' which allocates its own buffer:\n    file_data = gp.check_result(gp.gp_file_get_data_and_size(camera_file))\n    # Open with ImageIO:\n    data = imageio.imread(BytesIO(file_data))\n    # Add data as RGB channel to hal.DataItem object:\n    data_item.add_channel(self.channels()[0], data)\n    return data_item\n</code></pre>"},{"location":"reference/plantimager/gp2/#plantimager.gp2.Camera.grab_write","title":"<code>grab_write(target)</code>","text":"<p>Grab &amp; save a picture with gPhoto2.</p> Source code in <code>plantimager/gp2.py</code> <pre><code>def grab_write(self, target: str):\n    \"\"\"Grab &amp; save a picture with gPhoto2. \"\"\"\n    file_path = self.camera.capture(0)\n    camera_file = self.camera.file_get(file_path.folder, file_path.name,\n                                       gp.GP_FILE_TYPE_NORMAL)\n    gp.gp_file_save(camera_file, target)\n    return target\n</code></pre>"},{"location":"reference/plantimager/grbl/","title":"grbl","text":"<p>Implementation of a CNC module adapted to Grbl motherboard.</p> <p>The CNC is used to move a multi-purpose arm. It offers 3-axis of movements.</p>"},{"location":"reference/plantimager/grbl/#plantimager.grbl.CNC","title":"<code>CNC(port='/dev/ttyUSB0', baudrate=115200, homing=True, safe_start=True, x_lims=None, y_lims=None, z_lims=None, invert_x=True, invert_y=True, invert_z=True)</code>","text":"<p>             Bases: <code>AbstractCNC</code></p> <p>CNC functionalities.</p> <p>Attributes:</p> Name Type Description <code>port</code> <code>str</code> <p>Serial port to use for communication with the CNC controller (Arduino UNO).</p> <code>baudrate</code> <code>int</code> <p>Communication baud rate, <code>115200</code> whould work with the Arduino UNO.</p> <code>homing</code> <code>bool</code> <p>If <code>True</code>, axes homing will be performed upon CNC object instantiation [RECOMMENDED].</p> <code>x_lims</code> <code>(int, int)</code> <p>The allowed range of X-axis positions.</p> <code>y_lims</code> <code>(int, int)</code> <p>The allowed range of Y-axis positions.</p> <code>z_lims</code> <code>(int, int)</code> <p>The allowed range of Z-axis positions.</p> <code>serial_port</code> <code>Serial</code> <p>The <code>Serial</code> instance used to send commands to the Grbl.</p> <code>x</code> <code>int</code> <p>The current position, in millimeter, of the CNC arm on the X-axis.</p> <code>y</code> <code>int</code> <p>The current position, in millimeter, of the CNC arm on the Y-axis.</p> <code>z</code> <code>int</code> <p>The current position, in millimeter, of the CNC arm on the Z-axis.</p> <code>invert_x</code> <code>bool</code> <p>If <code>True</code>, \"mirror\" the coordinates direction respectively to 0.</p> <code>invert_y</code> <code>bool</code> <p>If <code>True</code>, \"mirror\" the coordinates direction respectively to 0.</p> <code>invert_z</code> <code>bool</code> <p>If <code>True</code>, \"mirror\" the coordinates direction respectively to 0.</p> References <p>http://linuxcnc.org/docs/html/gcode/g-code.html</p> See Also <p>plantimager.hal.AbstractCNC</p> Example <p>from plantimager.grbl import CNC cnc = CNC(\"/dev/ttyACM0\",x_lims=[0, 780],y_lims=[0, 780],z_lims=[0, 90]) cnc.moveto(200, 200, 50)  # move the CNC to this XYZ coordinate (in mm)</p> <p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>Serial port to use for communication with the CNC controller. This can also be a regular expression to identify in a unique way the corresponding port. Defaults to <code>\"/dev/ttyUSB0\"</code>.</p> <code>'/dev/ttyUSB0'</code> <code>baudrate</code> <code>int</code> <p>Communication baud rate, <code>115200</code> should work with the Arduino UNO.</p> <code>115200</code> <code>homing</code> <code>bool</code> <p>If <code>True</code> (default), axes homing will be performed upon CNC object instantiation [RECOMMENDED].</p> <code>True</code> <code>safe_start</code> <code>bool</code> <p>If <code>True</code>, check the object have been initialized with proper axes limits.</p> <code>True</code> <code>x_lims</code> <code>(int, int)</code> <p>The allowed range of X-axis positions, if <code>None</code> (default) use the settings from Grbl (\"$130\", see GRBL_SETTINGS).</p> <code>None</code> <code>y_lims</code> <code>(int, int)</code> <p>The allowed range of Y-axis positions, if <code>None</code> (default) use the settings from Grbl (\"$131\", see GRBL_SETTINGS).</p> <code>None</code> <code>z_lims</code> <code>(int, int)</code> <p>The allowed range of Z-axis positions, if <code>None</code> (default) use the settings from Grbl (\"$132\", see GRBL_SETTINGS).</p> <code>None</code> <code>invert_x</code> <code>bool</code> <p>If <code>True</code> (default), \"mirror\" the coordinates direction respectively to 0.</p> <code>True</code> <code>invert_y</code> <code>bool</code> <p>If <code>True</code> (default), \"mirror\" the coordinates direction respectively to 0.</p> <code>True</code> <code>invert_z</code> <code>bool</code> <p>If <code>True</code> (default), \"mirror\" the coordinates direction respectively to 0.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from plantimager.grbl import CNC\n&gt;&gt;&gt; cnc = CNC(\"Arduino\",x_lims=[0, 780],y_lims=[0, 780],z_lims=[0, 90])\n&gt;&gt;&gt; cnc.moveto(200, 200, 50)  # move the CNC to this XYZ coordinate (in mm)\n&gt;&gt;&gt; cnc.home()  # homing command (automatically called on startup)\n&gt;&gt;&gt; cnc.moveto_async(200, 200, 50)\n&gt;&gt;&gt; cnc.send_cmd(\"$$\")  # send a Grbl command, here \"$$\"\n&gt;&gt;&gt; cnc.print_grbl_settings()  # Get Grbl settings from the firmware\n&gt;&gt;&gt; cnc.stop()  # close the serial connection\n</code></pre> Source code in <code>plantimager/grbl.py</code> <pre><code>def __init__(self, port=\"/dev/ttyUSB0\", baudrate=115200, homing=True, safe_start=True,\n             x_lims=None, y_lims=None, z_lims=None, invert_x=True, invert_y=True, invert_z=True):\n    \"\"\"Constructor.\n\n    Parameters\n    ----------\n    port : str, optional\n        Serial port to use for communication with the CNC controller.\n        This can also be a regular expression to identify in a unique way the corresponding port.\n        Defaults to `\"/dev/ttyUSB0\"`.\n    baudrate : int, optional\n        Communication baud rate, `115200` should work with the Arduino UNO.\n    homing : bool, optional\n        If `True` (default), axes homing will be performed upon CNC object instantiation [RECOMMENDED].\n    safe_start : bool, optional\n        If ``True``, check the object have been initialized with proper axes limits.\n    x_lims : (int, int), optional\n        The allowed range of X-axis positions, if `None` (default) use the settings from Grbl (\"$130\", see GRBL_SETTINGS).\n    y_lims : (int, int), optional\n        The allowed range of Y-axis positions, if `None` (default) use the settings from Grbl (\"$131\", see GRBL_SETTINGS).\n    z_lims : (int, int), optional\n        The allowed range of Z-axis positions, if `None` (default) use the settings from Grbl (\"$132\", see GRBL_SETTINGS).\n    invert_x : bool, optional\n        If `True` (default), \"mirror\" the coordinates direction respectively to 0.\n    invert_y : bool, optional\n        If `True` (default), \"mirror\" the coordinates direction respectively to 0.\n    invert_z : bool, optional\n        If `True` (default), \"mirror\" the coordinates direction respectively to 0.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from plantimager.grbl import CNC\n    &gt;&gt;&gt; cnc = CNC(\"Arduino\",x_lims=[0, 780],y_lims=[0, 780],z_lims=[0, 90])\n    &gt;&gt;&gt; cnc.moveto(200, 200, 50)  # move the CNC to this XYZ coordinate (in mm)\n    &gt;&gt;&gt; cnc.home()  # homing command (automatically called on startup)\n    &gt;&gt;&gt; cnc.moveto_async(200, 200, 50)\n    &gt;&gt;&gt; cnc.send_cmd(\"$$\")  # send a Grbl command, here \"$$\"\n    &gt;&gt;&gt; cnc.print_grbl_settings()  # Get Grbl settings from the firmware\n    &gt;&gt;&gt; cnc.stop()  # close the serial connection\n\n    \"\"\"\n    super().__init__()\n    self.port = port if port.startswith('/dev') else guess_port(port)\n    self.baudrate = baudrate\n    self.x_lims = x_lims\n    self.y_lims = y_lims\n    self.z_lims = z_lims\n    self.invert_x = invert_x\n    self.invert_y = invert_y\n    self.invert_z = invert_z\n    self.serial_port = None\n    self.x = 0\n    self.y = 0\n    self.z = 0\n    self.grbl_settings = None\n    self._start(homing, safe_start)\n    atexit.register(self.stop)\n</code></pre>"},{"location":"reference/plantimager/grbl/#plantimager.grbl.CNC.get_grbl_settings","title":"<code>get_grbl_settings()</code>","text":"<p>Returns the Grbl settings as a dictionary {'param': value}.</p> Source code in <code>plantimager/grbl.py</code> <pre><code>def get_grbl_settings(self) -&gt; dict:\n    \"\"\" Returns the Grbl settings as a dictionary {'param': value}.\"\"\"\n    self.serial_port.reset_input_buffer()\n    self.serial_port.write((\"$$\" + \"\\n\").encode())\n    str_settings = self.serial_port.readlines()\n    settings = {}\n    for line in str_settings:\n        line = line.strip()  # remove potential leading and trailing whitespace &amp; eol\n        line = line.decode()\n        if not line.startswith('$'):\n            # All params are prefixed with a dollar sign '$'\n            continue\n        param, value = line.split(\"=\")\n        try:\n            settings[param] = int(value)\n        except ValueError:\n            settings[param] = float(value)\n\n    logger.info(\"Grbl settings loaded from firmware!\")\n    return settings\n</code></pre>"},{"location":"reference/plantimager/grbl/#plantimager.grbl.CNC.get_position","title":"<code>get_position()</code>","text":"<p>Returns the x, y &amp; z positions of the CNC.</p> Source code in <code>plantimager/grbl.py</code> <pre><code>def get_position(self):\n    \"\"\"Returns the x, y &amp; z positions of the CNC.\"\"\"\n    return self.x, self.y, self.z\n</code></pre>"},{"location":"reference/plantimager/grbl/#plantimager.grbl.CNC.get_status","title":"<code>get_status()</code>","text":"<p>Returns Grbl status.</p> Source code in <code>plantimager/grbl.py</code> <pre><code>def get_status(self) -&gt; dict:\n    \"\"\" Returns Grbl status.\"\"\"\n    self.serial_port.write(\"?\".encode(\"utf-8\"))\n    try:\n        res = self.serial_port.readline()\n        res = res.decode(\"utf-8\")\n        res = res[1:-1]\n        res = res.split('|')\n        print(res)\n        res_fmt = {}\n        res_fmt['status'] = res[0]\n        pos = res[1].split(':')[-1].split(',')\n        pos = [-float(p) for p in pos]  # why - ?\n        res_fmt['position'] = pos\n    except:\n        return None\n    return res_fmt\n</code></pre>"},{"location":"reference/plantimager/grbl/#plantimager.grbl.CNC.home","title":"<code>home()</code>","text":"<p>Performs axes homing procedure.</p> References <p>https://github.com/gnea/grbl/wiki/Grbl-v1.1-Commands#h---run-homing-cycle http://linuxcnc.org/docs/html/gcode/g-code.html#gcode:g92</p> Source code in <code>plantimager/grbl.py</code> <pre><code>def home(self):\n    \"\"\"Performs axes homing procedure.\n\n    References\n    ----------\n    https://github.com/gnea/grbl/wiki/Grbl-v1.1-Commands#h---run-homing-cycle\n    http://linuxcnc.org/docs/html/gcode/g-code.html#gcode:g92\n\n    \"\"\"\n    # Send Grbl homing command:\n    self.send_cmd(\"$H\")\n    # self.send_cmd(\"g28\") #reaching workspace origin\n    # Set current position to [0, 0, 0] (origin)\n    # Note that there is a 'homing pull-off' value ($27)!\n    self.send_cmd(\"g92 x0 y0 z0\")\n    return None\n</code></pre>"},{"location":"reference/plantimager/grbl/#plantimager.grbl.CNC.moveto","title":"<code>moveto(x, y, z)</code>","text":"<p>Send a 'G0' move command and wait until reaching target XYZ position.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The target position, in millimeters, along the X-axis.</p> required <code>y</code> <code>int</code> <p>The target position, in millimeters, along the Y-axis.</p> required <code>z</code> <code>int</code> <p>The target position, in millimeters, along the Z-axis.</p> required Source code in <code>plantimager/grbl.py</code> <pre><code>def moveto(self, x, y, z):\n    \"\"\"Send a 'G0' move command and wait until reaching target XYZ position.\n\n    Parameters\n    ----------\n    x : int\n        The target position, in millimeters, along the X-axis.\n    y : int\n        The target position, in millimeters, along the Y-axis.\n    z : int\n        The target position, in millimeters, along the Z-axis.\n\n    \"\"\"\n    self._check_move(x, y, z)\n    self.moveto_async(x, y, z)\n    self.wait()\n    return None\n</code></pre>"},{"location":"reference/plantimager/grbl/#plantimager.grbl.CNC.moveto_async","title":"<code>moveto_async(x, y, z)</code>","text":"<p>Send a non-blocking 'G0' move command to target XYZ position.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The target position, in millimeters, along the X-axis.</p> required <code>y</code> <code>int</code> <p>The target position, in millimeters, along the Y-axis.</p> required <code>z</code> <code>int</code> <p>The target position, in millimeters, along the Z-axis.</p> required References <p>http://linuxcnc.org/docs/html/gcode/g-code.html#gcode:g0</p> Source code in <code>plantimager/grbl.py</code> <pre><code>def moveto_async(self, x, y, z):\n    \"\"\"Send a non-blocking 'G0' move command to target XYZ position.\n\n    Parameters\n    ----------\n    x : int\n        The target position, in millimeters, along the X-axis.\n    y : int\n        The target position, in millimeters, along the Y-axis.\n    z : int\n        The target position, in millimeters, along the Z-axis.\n\n    References\n    ----------\n    http://linuxcnc.org/docs/html/gcode/g-code.html#gcode:g0\n\n    \"\"\"\n    x = int(-x) if self.invert_x else int(x)\n    y = int(-y) if self.invert_y else int(y)\n    z = int(-z) if self.invert_z else int(z)\n    self.send_cmd(f\"g0 x{x} y{y} z{z}\")\n    self.x, self.y, self.z = x, y, z\n    time.sleep(0.1)  # Add a little sleep between calls\n    return None\n</code></pre>"},{"location":"reference/plantimager/grbl/#plantimager.grbl.CNC.print_grbl_settings","title":"<code>print_grbl_settings()</code>","text":"<p>Print the Grbl settings.</p> See Also <p>GRBL_SETTINGS</p> References <p>https://github.com/gnea/grbl/wiki/Grbl-v1.1-Configuration#grbl-settings</p> Source code in <code>plantimager/grbl.py</code> <pre><code>def print_grbl_settings(self):\n    \"\"\" Print the Grbl settings.\n\n    See Also\n    --------\n    GRBL_SETTINGS\n\n    References\n    ----------\n    https://github.com/gnea/grbl/wiki/Grbl-v1.1-Configuration#grbl-settings\n\n    \"\"\"\n    settings = self.get_grbl_settings()\n    print(\"Obtained Grbl settings:\")\n    for param, value in settings.items():\n        param_name, param_unit = GRBL_SETTINGS[param]\n        if param_unit in ['boolean', 'mask']:\n            param_unit = f\"({param_unit})\"\n        print(f\" - ({param}) {param_name}: {value} {param_unit}\")\n    return None\n</code></pre>"},{"location":"reference/plantimager/grbl/#plantimager.grbl.CNC.send_cmd","title":"<code>send_cmd(cmd)</code>","text":"<p>Send given command to Grbl.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>str</code> <p>A Grbl compatible command.</p> required References <p>https://github.com/gnea/grbl/wiki/Grbl-v1.1-Commands</p> Source code in <code>plantimager/grbl.py</code> <pre><code>def send_cmd(self, cmd):\n    \"\"\" Send given command to Grbl.\n\n    Parameters\n    ----------\n    cmd : str\n        A Grbl compatible command.\n\n    References\n    ----------\n    https://github.com/gnea/grbl/wiki/Grbl-v1.1-Commands\n\n    \"\"\"\n    self.serial_port.reset_input_buffer()\n    logger.debug(f\"{cmd} -&gt; cnc\")\n    self.serial_port.write((cmd + \"\\n\").encode())\n    grbl_out = self.serial_port.readline()\n    logger.debug(f\"cnc -&gt; {grbl_out.strip()}\")\n    time.sleep(0.1)\n    return grbl_out\n</code></pre>"},{"location":"reference/plantimager/grbl/#plantimager.grbl.CNC.stop","title":"<code>stop()</code>","text":"<p>Close the serial connection.</p> Source code in <code>plantimager/grbl.py</code> <pre><code>def stop(self):\n    \"\"\"Close the serial connection.\"\"\"\n    if (self.has_started):\n        self.serial_port.close()\n    return None\n</code></pre>"},{"location":"reference/plantimager/grbl/#plantimager.grbl.CNC.wait","title":"<code>wait()</code>","text":"<p>Send a 1-second wait (dwell) command to Grbl.</p> References <p>http://linuxcnc.org/docs/html/gcode/g-code.html#gcode:g4</p> Source code in <code>plantimager/grbl.py</code> <pre><code>def wait(self):\n    \"\"\" Send a 1-second wait (dwell) command to Grbl.\n\n    References\n    ----------\n    http://linuxcnc.org/docs/html/gcode/g-code.html#gcode:g4\n\n    \"\"\"\n    self.send_cmd(\"g4 p1\")\n    return None\n</code></pre>"},{"location":"reference/plantimager/hal/","title":"hal","text":""},{"location":"reference/plantimager/hal/#plantimager.hal.AbstractCNC","title":"<code>AbstractCNC()</code>","text":"<p>Abstract CNC class.</p> Source code in <code>plantimager/hal.py</code> <pre><code>def __init__(self):\n    pass\n</code></pre>"},{"location":"reference/plantimager/hal/#plantimager.hal.AbstractCamera","title":"<code>AbstractCamera</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract Camera class.</p>"},{"location":"reference/plantimager/hal/#plantimager.hal.AbstractCamera.grab","title":"<code>grab(idx, metadata=None)</code>  <code>abstractmethod</code>","text":"<p>Grab data with an id and metadata.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Id of the data <code>DataItem</code> to create.</p> required <code>metadata</code> <code>dict</code> <p>Dictionary of metadata associated to the camera data.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataItem</code> <p>The image data.</p> Source code in <code>plantimager/hal.py</code> <pre><code>@abstractmethod\ndef grab(self, idx: int, metadata: dict = None):\n    \"\"\"Grab data with an id and metadata.\n\n    Parameters\n    ----------\n    idx : int\n        Id of the data `DataItem` to create.\n    metadata : dict, optional\n        Dictionary of metadata associated to the camera data.\n\n    Returns\n    -------\n    plantimager.hal.DataItem\n        The image data.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/plantimager/hal/#plantimager.hal.AbstractGimbal","title":"<code>AbstractGimbal</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract Gimbal class.</p>"},{"location":"reference/plantimager/hal/#plantimager.hal.AbstractScanner","title":"<code>AbstractScanner()</code>","text":"<p>An abstract scanner class.</p> <p>Attributes:</p> Name Type Description <code>scan_count</code> <code>int</code> <p>Incremental counter saving last picture index for the <code>grab</code> method. Modified by the <code>inc_count</code> method.</p> <code>ext</code> <code>str</code> <p>Extension to use to write image data from the <code>grab</code> method.</p> Source code in <code>plantimager/hal.py</code> <pre><code>def __init__(self):\n    self.scan_count = 0\n    self.ext = 'jpg'\n    super().__init__()\n</code></pre>"},{"location":"reference/plantimager/hal/#plantimager.hal.AbstractScanner.channels","title":"<code>channels()</code>  <code>abstractmethod</code>","text":"<p>Channel names associated to data from <code>grab</code> method.</p> See Also <p>plantimager.hal.AbstractCamera</p> Source code in <code>plantimager/hal.py</code> <pre><code>@abstractmethod\ndef channels(self) -&gt; List[str]:\n    \"\"\"Channel names associated to data from `grab` method.\n\n    See Also\n    --------\n    plantimager.hal.AbstractCamera\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/plantimager/hal/#plantimager.hal.AbstractScanner.get_position","title":"<code>get_position()</code>  <code>abstractmethod</code>","text":"<p>Get the current position of the scanner.</p> Source code in <code>plantimager/hal.py</code> <pre><code>@abstractmethod\ndef get_position(self) -&gt; Pose:\n    \"\"\"Get the current position of the scanner.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/plantimager/hal/#plantimager.hal.AbstractScanner.get_target_pose","title":"<code>get_target_pose(elt)</code>","text":"<p>Get the target pose from a given path element (singleton).</p> <p>Parameters:</p> Name Type Description Default <code>elt</code> <code>PathElement</code> <p>The path element to reach.</p> required <p>Returns:</p> Type Description <code>Pose</code> <p>The target pose to reach.</p> Notes <p>If a <code>Pose</code> attribute is missing from the given path element, we use the value from the previous pose.</p> Source code in <code>plantimager/hal.py</code> <pre><code>def get_target_pose(self, elt):\n    \"\"\"Get the target pose from a given path element (singleton).\n\n    Parameters\n    ----------\n    elt : plantimager.path.PathElement\n        The path element to reach.\n\n    Returns\n    -------\n    plantimager.path.Pose\n        The target pose to reach.\n\n    Notes\n    -----\n    If a ``Pose`` attribute is missing from the given path element, we use the value from the previous pose.\n    \"\"\"\n    pos = self.get_position()\n    target_pose = Pose()\n    for attr in pos.attributes():\n        if getattr(elt, attr) is None:\n            setattr(target_pose, attr, getattr(pos, attr))\n        else:\n            setattr(target_pose, attr, getattr(elt, attr))\n    return target_pose\n</code></pre>"},{"location":"reference/plantimager/hal/#plantimager.hal.AbstractScanner.grab","title":"<code>grab(idx, metadata)</code>  <code>abstractmethod</code>","text":"<p>Grab data with an id and metadata.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Id of the data <code>DataItem</code> to create.</p> required <code>metadata</code> <code>dict</code> <p>Dictionary of metadata associated to the camera data.</p> required <p>Returns:</p> Type Description <code>DataItem</code> <p>The image data &amp; metadata.</p> See Also <p>plantimager.hal.AbstractCamera</p> Source code in <code>plantimager/hal.py</code> <pre><code>@abstractmethod\ndef grab(self, idx, metadata):\n    \"\"\"Grab data with an id and metadata.\n\n    Parameters\n    ----------\n    idx : int\n        Id of the data `DataItem` to create.\n    metadata : dict, optional\n        Dictionary of metadata associated to the camera data.\n\n    Returns\n    -------\n    plantimager.hal.DataItem\n        The image data &amp; metadata.\n\n    See Also\n    --------\n    plantimager.hal.AbstractCamera\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/plantimager/hal/#plantimager.hal.AbstractScanner.inc_count","title":"<code>inc_count()</code>","text":"<p>Incremental counter used to return a picture index for the <code>grab</code> method.</p> Source code in <code>plantimager/hal.py</code> <pre><code>def inc_count(self) -&gt; int:\n    \"\"\"Incremental counter used to return a picture index for the ``grab`` method.\"\"\"\n    x = self.scan_count\n    self.scan_count += 1\n    return x\n</code></pre>"},{"location":"reference/plantimager/hal/#plantimager.hal.AbstractScanner.scan","title":"<code>scan(path, fileset)</code>","text":"<p>Performs a scan, that is a series of movements and image acquisitions.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to follows to acquire image.</p> required <code>fileset</code> <code>Fileset</code> <p>The output fileset used to save the image.</p> required Source code in <code>plantimager/hal.py</code> <pre><code>def scan(self, path, fileset):\n    \"\"\"Performs a scan, that is a series of movements and image acquisitions.\n\n    Parameters\n    ----------\n    path : plantimager.path.Path\n        The path to follows to acquire image.\n    fileset : plantdb.FSDB.Fileset\n        The output fileset used to save the image.\n    \"\"\"\n    for x in tqdm(path, unit='pose'):\n        pose = self.get_target_pose(x)\n        data_item = self.scan_at(pose, x.exact_pose)\n        for c in self.channels():\n            f = fileset.create_file(data_item.channels[c].format_id())\n            data = data_item.channels[c].data\n            if \"float\" in data.dtype.name:\n                data = np.array(data * 255).astype(\"uint8\")\n            io.write_image(f, data, ext=self.ext)\n            if data_item.metadata is not None:\n                f.set_metadata(data_item.metadata)\n            f.set_metadata(\"shot_id\", \"%06i\" % data_item.idx)\n            f.set_metadata(\"channel\", c)\n    return\n</code></pre>"},{"location":"reference/plantimager/hal/#plantimager.hal.AbstractScanner.scan_at","title":"<code>scan_at(pose, exact_pose=True, metadata=None)</code>","text":"<p>Move to a given position and take a picture.</p> <p>Parameters:</p> Name Type Description Default <code>pose</code> <code>Pose</code> <p>The position of the camera to take the picture.</p> required <code>exact_pose</code> <code>bool</code> <p>If <code>True</code> (default), save the given <code>pose</code> under a \"pose\" entry in metadata. Else, save it as an \"approximate_pose\" entry in metadata.</p> <code>True</code> <code>metadata</code> <code>dict</code> <p>The dictionary of metadata to associate to this picture.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataItem</code> <p>The picture data &amp; metadata.</p> Source code in <code>plantimager/hal.py</code> <pre><code>def scan_at(self, pose, exact_pose=True, metadata=None):\n    \"\"\"Move to a given position and take a picture.\n\n    Parameters\n    ----------\n    pose : plantimager.path.Pose\n        The position of the camera to take the picture.\n    exact_pose : bool, optional\n        If ``True`` (default), save the given `pose` under a \"pose\" entry in metadata.\n        Else, save it as an \"approximate_pose\" entry in metadata.\n    metadata : dict, optional\n        The dictionary of metadata to associate to this picture.\n\n    Returns\n    -------\n    plantimager.hal.DataItem\n        The picture data &amp; metadata.\n    \"\"\"\n    logger.debug(f\"scanning at: {pose}\")\n    if metadata is None:\n        metadata = {}\n    if exact_pose:\n        metadata = {**metadata, \"pose\": [pose.x, pose.y, pose.z, pose.pan, pose.tilt]}\n    else:\n        metadata = {**metadata, \"approximate_pose\": [pose.x, pose.y, pose.z, pose.pan, pose.tilt]}\n    logger.debug(f\"with metadata: {metadata}\")\n    self.set_position(pose)\n    return self.grab(self.inc_count(), metadata=metadata)\n</code></pre>"},{"location":"reference/plantimager/hal/#plantimager.hal.AbstractScanner.set_position","title":"<code>set_position(pose)</code>  <code>abstractmethod</code>","text":"<p>Set the position of the scanner from a 5D Pose.</p> Source code in <code>plantimager/hal.py</code> <pre><code>@abstractmethod\ndef set_position(self, pose: Pose) -&gt; None:\n    \"\"\"Set the position of the scanner from a 5D Pose.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/plantimager/log/","title":"log","text":""},{"location":"reference/plantimager/log/#plantimager.log.configure_logger","title":"<code>configure_logger(name, log_path='', log_level='INFO')</code>","text":"<p>Return a configured logger.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the logger.</p> required <code>log_path</code> <code>str</code> <p>A file path to save the log. Defaults to <code>''</code>.</p> <code>''</code> <code>log_level</code> <code>(CRITICAL, ERROR, WARNING, INFO, DEBUG, NOTSET)</code> <p>A valid logging level. Defaults to <code>'INFO'</code>.</p> <code>'CRITICAL'</code> Source code in <code>plantimager/log.py</code> <pre><code>def configure_logger(name, log_path=\"\", log_level='INFO'):\n    \"\"\"Return a configured logger.\n\n    Parameters\n    ----------\n    name : str\n        The name of the logger.\n    log_path : str\n        A file path to save the log.\n        Defaults to `''`.\n    log_level : {'CRITICAL', 'ERROR', 'WARNING', 'INFO', 'DEBUG', 'NOTSET'}\n        A valid logging level.\n        Defaults to `'INFO'`.\n    \"\"\"\n    colored_formatter = ColoredFormatter(\n        \"%(log_color)s%(levelname)-8s%(reset)s %(bg_blue)s[%(name)s]%(reset)s %(message)s\",\n        datefmt=None,\n        reset=True,\n        style='%',\n    )\n    simple_formatter = logging.Formatter(\"%(asctime)s - %(levelname)s - %(name)s - %(lineno)d: %(message)s\")\n\n    # create console handler:\n    console = logging.StreamHandler()\n    console.setFormatter(colored_formatter)\n\n    logger = logging.getLogger(name)\n    logger.addHandler(console)\n    logger.setLevel(getattr(logging, log_level))\n\n    if log_path is not None and log_path != \"\":\n        # create file handler:\n        fh = logging.FileHandler(Path(log_path) / f'{name}.log', mode='w')\n        fh.setFormatter(simple_formatter)\n        logger.addHandler(fh)\n\n    return logger\n</code></pre>"},{"location":"reference/plantimager/log/#plantimager.log.get_logging_config","title":"<code>get_logging_config(name='root', log_level='INFO')</code>","text":"<p>Return the logging configuration.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the logger. Defaults to <code>'root'</code>.</p> <code>'root'</code> <code>log_level</code> <code>(CRITICAL, ERROR, WARNING, INFO, DEBUG, NOTSET)</code> <p>A valid logging level. Defaults to <code>'INFO'</code>.</p> <code>'CRITICAL'</code> Source code in <code>plantimager/log.py</code> <pre><code>def get_logging_config(name='root', log_level='INFO'):\n    \"\"\"Return the logging configuration.\n\n    Parameters\n    ----------\n    name : str\n        The name of the logger.\n        Defaults to `'root'`.\n    log_level : {'CRITICAL', 'ERROR', 'WARNING', 'INFO', 'DEBUG', 'NOTSET'}\n        A valid logging level.\n        Defaults to `'INFO'`.\n    \"\"\"\n    return LOGGING_CFG.format(name, log_level)\n</code></pre>"},{"location":"reference/plantimager/lpy/","title":"lpy","text":""},{"location":"reference/plantimager/path/","title":"path","text":""},{"location":"reference/plantimager/path/#plantimager.path.CalibrationPath","title":"<code>CalibrationPath(path, n_points_line=11, x_lims=None, y_lims=None)</code>","text":"<p>             Bases: <code>Path</code></p> <p>Creates a calibration path for the Plant Imager.</p> Notes <p>The calibration path is made of the path to calibrate, plus four linear paths:   1. a \"y-line\" (from <code>y_min</code> to <code>y_max</code>) at <code>x_min</code>, facing <code>x_max</code> with <code>n_points_line</code> poses   2. a first \"half x-line\" (from <code>x_min</code> to <code>x_max/2</code>) at <code>y_max/2</code>, facing <code>x_max</code> with <code>n_points_line/2</code> poses   3. a second \"half x-line\" (from <code>x_max/2</code> to <code>x_max</code>) at <code>y_max/2</code>, facing <code>x_min</code> with <code>n_points_line/2</code> poses   4. a \"y-line\" (from <code>y_min</code> to <code>y_max</code>) at <code>x_max</code>, facing <code>x_min</code> with <code>n_points_line</code> poses The central and extreme points of the \"x-line\" at <code>y_max/2</code> are removed to avoid duplicates.</p> See Also <p>plant3dvision.tasks.colmap.use_calibrated_poses</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from plantimager.path import CalibrationPath\n&gt;&gt;&gt; from plantimager.path import Circle\n&gt;&gt;&gt; n_points_circle = 36\n&gt;&gt;&gt; circular_path = Circle(300, 300, 50, 0, 250, n_points_circle)\n&gt;&gt;&gt; n_points_line = 11\n&gt;&gt;&gt; calib_path = CalibrationPath(circular_path, n_points_line, x_lims=[0, 600], y_lims=[0, 600])\n&gt;&gt;&gt; calib_path[36:]  # the calibration lines\n&gt;&gt;&gt; len(calib_path) == n_points_circle + n_points_line*3\n&gt;&gt;&gt; # View the Calibration points coordinates:\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; x,y = np.array([(p.x, p.y) for p in calib_path]).T  # get the XY coordinates\n&gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8,8))\n&gt;&gt;&gt; ax.scatter(x[:36], y[:36], marker='+', color=['r']*n_points_circle, label=\"Circle\")\n&gt;&gt;&gt; ax.scatter(x[36:], y[36:], marker='x', color=['b']*(n_points_line*3-3), label=\"Lines\")\n&gt;&gt;&gt; [ax.text(x[i], y[i], str(i)) for i in range(len(x))]\n&gt;&gt;&gt; ax.grid(True, which='major', axis='both', linestyle='dotted')\n&gt;&gt;&gt; ax.set_aspect('equal')\n&gt;&gt;&gt; ax.legend()\n&gt;&gt;&gt; ax.set_title(\"Calibration path\")\n&gt;&gt;&gt; ax.set_xlabel(\"X-axis\")\n&gt;&gt;&gt; ax.set_ylabel(\"Y-axis\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>A path to calibrate.</p> required <code>n_points_line</code> <code>int</code> <p>The number of points per line, should be an odd number (or we will add one point). Defaults to <code>11</code> and should be greater or equal to <code>5</code>.</p> <code>11</code> <code>x_lims</code> <code>list of int</code> <p>Set the min/max <code>x</code> range for the calibration (do NOT apply to the path to calibrate). Else, will be set from the min/max of the path to calibrate on the x-axis.</p> <code>None</code> <code>y_lims</code> <code>list of int</code> <p>Set the min/max <code>y</code> range for the calibration (do NOT apply to the path to calibrate). Else, will be set from the min/max of the path to calibrate on the y-axis.</p> <code>None</code> Source code in <code>plantimager/path.py</code> <pre><code>def __init__(self, path, n_points_line=11, x_lims=None, y_lims=None):\n    \"\"\"\n    Parameters\n    ----------\n    path : Path\n        A path to calibrate.\n    n_points_line : int, optional\n        The number of points per line, should be an odd number (or we will add one point).\n        Defaults to `11` and should be greater or equal to `5`.\n    x_lims : list of int, optional\n        Set the min/max `x` range for the calibration (do NOT apply to the path to calibrate).\n        Else, will be set from the min/max of the path to calibrate on the x-axis.\n    y_lims : list of int, optional\n        Set the min/max `y` range for the calibration (do NOT apply to the path to calibrate).\n        Else, will be set from the min/max of the path to calibrate on the y-axis.\n    \"\"\"\n    super().__init__()\n    # Check the `n_points_line` parameter:\n    try:\n        assert n_points_line &gt;= 5\n    except:\n        raise ValueError(f\"CalibrationPath require a number of point per line &gt;= `5`, got {n_points_line}!\")\n\n    # - Start the calibration path with the path to calibrate:\n    self.extend(path)\n\n    p0 = path[0]  # get the first pose\n    # Compute the X &amp; Y range for calibration lines:\n    if x_lims is None:\n        x_coords = [pelt.x for pelt in path]\n        x_min, x_max = min(x_coords), max(x_coords)\n        # x_min = path[np.argmin([p_i.x - p0.x for p_i in path])].x\n        # x_max = path[np.argmax([p_i.x - p0.x for p_i in path])].x\n    else:\n        x_min, x_max = x_lims\n    if y_lims is None:\n        y_coords = [pelt.y for pelt in path]\n        y_min, y_max = min(y_coords), max(y_coords)\n        # y_min = path[np.argmin([p_i.y - p0.y for p_i in path])].y\n        # y_max = path[np.argmax([p_i.y - p0.y for p_i in path])].y\n    else:\n        y_min, y_max = y_lims\n\n    # Get the middle coordinates in X &amp; Y:\n    mid_x = (x_max - x_min) // 2. + x_min\n    mid_y = (y_max - y_min) // 2. + y_min\n    # Make sure the number of point per line is an odd number:\n    if n_points_line % 2 == 0:\n        n_points_line += 1\n    # Get the number of point to make a \"half line\":\n    n_points_half_line = n_points_line // 2 + 1\n\n    # Add the first Y-line at x-min, facing the x-max:\n    self.extend(Line(x_min, y_min, p0.z, x_min, y_max, p0.z, 270., p0.tilt, n_points_line))\n    # Add the first half X-line facing the x-max:\n    #  - remove the first pose as it has been done during the first Y-line at x-min\n    #  - remove the last pose as it would be at the center (and we want to exclude a central point)\n    self.extend(Line(x_min, mid_y, p0.z, mid_x, mid_y, p0.z, 270., p0.tilt, n_points_half_line)[1:-1])\n    # Add the second half X-line facing the x-min:\n    #  - remove the first pose as it would be at the center (and we want to exclude a central point)\n    #  - remove the last pose as it will be done during the second Y-line at x-max\n    self.extend(Line(mid_x, mid_y, p0.z, x_max, mid_y, p0.z, 90., p0.tilt, n_points_half_line)[1:-1])\n    # Add the second Y-line at x-max, facing the x-min:\n    self.extend(Line(x_max, y_min, p0.z, x_max, y_max, p0.z, 90., p0.tilt, n_points_line))\n</code></pre>"},{"location":"reference/plantimager/path/#plantimager.path.Circle","title":"<code>Circle(center_x, center_y, z, tilt, radius, n_points)</code>","text":"<p>             Bases: <code>Path</code></p> <p>Creates a circular path for the scanner.</p> <p>Compute the <code>x</code>, <code>y</code> &amp; <code>pan</code> <code>PathElement</code> values to create that circle.</p> Notes <p>The <code>pan</code> is computed to always face the center of the circle. If an iterable is given for <code>tilt</code>, performs more than one camera acquisition at same xyz position.</p> See Also <p>plantimager.path.circle</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from plantimager.path import Circle\n&gt;&gt;&gt; circular_path = Circle(200, 200, 50, 0, 200, 9)\n&gt;&gt;&gt; circular_path\n[x: 0.0, y: 200.0, z: 50, pan: 270.0, tilt: 0, exact_pose: False,\n x: 46.791111376204384, y: 71.44247806269215, z: 50, pan: 310.0, tilt: 0, exact_pose: False,\n x: 165.27036446661393, y: 3.038449397558395, z: 50, pan: 350.0, tilt: 0, exact_pose: False,\n x: 299.99999999999994, y: 26.794919243112247, z: 50, pan: 29.999999999999986, tilt: 0, exact_pose: False,\n x: 387.93852415718163, y: 131.59597133486622, z: 50, pan: 70.0, tilt: 0, exact_pose: False,\n x: 387.9385241571817, y: 268.40402866513375, z: 50, pan: 110.0, tilt: 0, exact_pose: False,\n x: 300.0000000000001, y: 373.2050807568877, z: 50, pan: 149.99999999999997, tilt: 0, exact_pose: False,\n x: 165.270364466614, y: 396.96155060244166, z: 50, pan: 190.0, tilt: 0, exact_pose: False,\n x: 46.79111137620444, y: 328.5575219373079, z: 50, pan: 230.0, tilt: 0, exact_pose: False]\n&gt;&gt;&gt; circular_path = Circle(200, 200, 50, (0, 10), 200, 2)\n&gt;&gt;&gt; circular_path\n[x: 0.0, y: 200.0, z: 50, pan: 270.0, tilt: 0, exact_pose: False,\n x: 0.0, y: 200.0, z: 50, pan: 270.0, tilt: 10, exact_pose: False,\n x: 400.0, y: 199.99999999999997, z: 50, pan: 90.0, tilt: 0, exact_pose: False,\n x: 400.0, y: 199.99999999999997, z: 50, pan: 90.0, tilt: 10, exact_pose: False]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>center_x</code> <code>length_mm</code> <p>X-axis position, in millimeters, of the circle's center, relative to the origin.</p> required <code>center_y</code> <code>length_mm</code> <p>Y-axis position, in millimeters, of the circle's center, relative to the origin.</p> required <code>z</code> <code>length_mm</code> <p>Height at which to make the circle.</p> required <code>tilt</code> <code>deg or list(deg)</code> <p>Camera tilt(s), in degrees, to use for this circle. If an iterable is given, performs more than one camera acquisition at same xyz position.</p> required <code>radius</code> <code>length_mm</code> <p>Radius, in millimeters, of the circular path to create.</p> required <code>n_points</code> <code>int</code> <p>Number of points (<code>PathElement</code>) used to generate the circular path.</p> required Source code in <code>plantimager/path.py</code> <pre><code>def __init__(self, center_x, center_y, z, tilt, radius, n_points):\n    \"\"\"\n    Parameters\n    ----------\n    center_x : length_mm\n        X-axis position, in millimeters, of the circle's center, relative to the origin.\n    center_y : length_mm\n        Y-axis position, in millimeters, of the circle's center, relative to the origin.\n    z : length_mm\n        Height at which to make the circle.\n    tilt : deg or list(deg)\n        Camera tilt(s), in degrees, to use for this circle.\n        If an iterable is given, performs more than one camera acquisition at same xyz position.\n    radius : length_mm\n        Radius, in millimeters, of the circular path to create.\n    n_points : int\n        Number of points (``PathElement``) used to generate the circular path.\n    \"\"\"\n    super().__init__()\n    x, y, pan = circle(center_x, center_y, radius, n_points)\n\n    if not isinstance(tilt, Iterable):\n        tilt = [tilt]\n\n    # FIXME: why do we set `exact_pose` to `False`?! What is the purpose of `exact_pose`?!\n    for i in range(n_points):\n        for t in tilt:\n            self.append(PathElement(x[i], y[i], z, pan[i], t, exact_pose=False))\n</code></pre>"},{"location":"reference/plantimager/path/#plantimager.path.Cylinder","title":"<code>Cylinder(center_x, center_y, z_range, tilt, radius, n_points, n_circles=2)</code>","text":"<p>             Bases: <code>Path</code></p> <p>Creates a z-axis aligned cylinder path for the scanner.</p> <p>Makes as much circular paths as <code>n_circles</code> within the given z range.</p> Notes <p>The <code>pan</code> is computed to always face the center of the circle. If an iterable is given for <code>tilt</code>, performs more than one camera acquisition at same xyz position.</p> See Also <p>plantimager.path.circle</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from plantimager.path import Cylinder\n&gt;&gt;&gt; cylinder_path = Cylinder(200, 200, (0, 50), 0, 200, n_points=2, n_circles=2)\n&gt;&gt;&gt; cylinder_path\n[x: 0.0, y: 200.0, z: 0, pan: 270.0, tilt: 0, exact_pose: False,\n x: 400.0, y: 199.99999999999997, z: 0, pan: 90.0, tilt: 0, exact_pose: False,\n x: 0.0, y: 200.0, z: 50, pan: 270.0, tilt: 0, exact_pose: False,\n x: 400.0, y: 199.99999999999997, z: 50, pan: 90.0, tilt: 0, exact_pose: False]\n&gt;&gt;&gt; cylinder_path = Cylinder(200, 200, (0, 50), 0, 200, n_points=2, n_circles=3)\n&gt;&gt;&gt; cylinder_path\n[x: 0.0, y: 200.0, z: 0.0, pan: 270.0, tilt: 0, exact_pose: False,\n x: 400.0, y: 199.99999999999997, z: 0.0, pan: 90.0, tilt: 0, exact_pose: False,\n x: 0.0, y: 200.0, z: 25.0, pan: 270.0, tilt: 0, exact_pose: False,\n x: 400.0, y: 199.99999999999997, z: 25.0, pan: 90.0, tilt: 0, exact_pose: False,\n x: 0.0, y: 200.0, z: 50.0, pan: 270.0, tilt: 0, exact_pose: False,\n x: 400.0, y: 199.99999999999997, z: 50.0, pan: 90.0, tilt: 0, exact_pose: False]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>center_x</code> <code>length_mm</code> <p>X-axis position, in millimeters, of the circle's center, relative to the origin.</p> required <code>center_y</code> <code>length_mm</code> <p>Y-axis position, in millimeters, of the circle's center, relative to the origin.</p> required <code>z_range</code> <code>(length_mm, length_mm)</code> <p>Height range, in millimeters, at which to make the cylinder.</p> required <code>tilt</code> <code>deg or list of deg</code> <p>Camera tilt(s), in degrees, to use for this circle. If an iterable is given, performs more than one camera acquisition at same xyz position.</p> required <code>radius</code> <code>length_mm</code> <p>Radius of the circular path to create.</p> required <code>n_points</code> <code>int</code> <p>Number of points (<code>PathElement</code>) used to generate the circular path.</p> required <code>n_circles</code> <code>int</code> <p>Number of circular path to make within the cylinder, minimum value is 2.</p> <code>2</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the number of circles <code>n_circles</code> is not superior or equal to <code>2</code>.</p> Source code in <code>plantimager/path.py</code> <pre><code>def __init__(self, center_x, center_y, z_range, tilt, radius, n_points, n_circles=2):\n    \"\"\"\n    Parameters\n    ----------\n    center_x : length_mm\n        X-axis position, in millimeters, of the circle's center, relative to the origin.\n    center_y : length_mm\n        Y-axis position, in millimeters, of the circle's center, relative to the origin.\n    z_range : (length_mm, length_mm)\n        Height range, in millimeters, at which to make the cylinder.\n    tilt : deg or list of deg\n        Camera tilt(s), in degrees, to use for this circle.\n        If an iterable is given, performs more than one camera acquisition at same xyz position.\n    radius : length_mm\n        Radius of the circular path to create.\n    n_points : int\n        Number of points (``PathElement``) used to generate the circular path.\n    n_circles : int, optional\n        Number of circular path to make within the cylinder, minimum value is 2.\n\n    Raises\n    ------\n    ValueError\n        If the number of circles `n_circles` is not superior or equal to `2`.\n\n    \"\"\"\n    super().__init__()\n\n    try:\n        assert n_circles &gt;= 2\n    except AssertionError:\n        raise ValueError(\"You need a minimum of two circles to make a cylinder!\")\n\n    min_z, max_z = z_range\n    for z_circle in np.arange(min_z, max_z + 1, (max_z - min_z) / float(n_circles - 1)):\n        self.extend(Circle(center_x, center_y, z_circle, tilt, radius, n_points))\n</code></pre>"},{"location":"reference/plantimager/path/#plantimager.path.Line","title":"<code>Line(x_start, y_start, z_start, x_stop, y_stop, z_stop, pan, tilt, n_points)</code>","text":"<p>             Bases: <code>Path</code></p> <p>Creates a linear path for the scanner.</p> See Also <p>plantimager.path.line3d</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from plantimager.path import Line\n&gt;&gt;&gt; linear_path = Line(0, 0, 0, 10, 10, 0, 180, 0, n_points=2)\n&gt;&gt;&gt; linear_path\n[x: 0.0, y: 0.0, z: 0.0, pan: 180, tilt: 0, exact_pose: True,\n x: 10.0, y: 10.0, z: 0.0, pan: 180, tilt: 0, exact_pose: True]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>x_start</code> <code>length_mm</code> <p>Line starting position, in millimeters for the x-axis.</p> required <code>y_start</code> <code>length_mm</code> <p>Line starting position, in millimeters for the y-axis.</p> required <code>z_start</code> <code>length_mm</code> <p>Line starting position, in millimeters for the z-axis.</p> required <code>x_stop</code> <code>length_mm</code> <p>Line ending position, in millimeters for the x-axis.</p> required <code>y_stop</code> <code>length_mm</code> <p>Line ending position, in millimeters for the y-axis.</p> required <code>z_stop</code> <code>length_mm</code> <p>Line ending position, in millimeters for the z-axis.</p> required <code>pan</code> <code>deg</code> <p>Camera pan value, in degrees, to use for the linear path.</p> required <code>tilt</code> <code>deg or list(deg)</code> <p>Camera tilt(s), in degrees, to use for this circle. If an iterable is given, performs more than one camera acquisition at same xyz position.</p> required <code>n_points</code> <code>int</code> <p>Number of points used to create the linear path.</p> required Source code in <code>plantimager/path.py</code> <pre><code>def __init__(self, x_start, y_start, z_start, x_stop, y_stop, z_stop, pan, tilt, n_points):\n    \"\"\"\n    Parameters\n    ----------\n    x_start : length_mm\n        Line starting position, in millimeters for the x-axis.\n    y_start : length_mm\n        Line starting position, in millimeters for the y-axis.\n    z_start : length_mm\n        Line starting position, in millimeters for the z-axis.\n    x_stop : length_mm\n        Line ending position, in millimeters for the x-axis.\n    y_stop : length_mm\n        Line ending position, in millimeters for the y-axis.\n    z_stop : length_mm\n        Line ending position, in millimeters for the z-axis.\n    pan : deg\n        Camera pan value, in degrees, to use for the linear path.\n    tilt : deg or list(deg)\n        Camera tilt(s), in degrees, to use for this circle.\n        If an iterable is given, performs more than one camera acquisition at same xyz position.\n    n_points : int\n        Number of points used to create the linear path.\n    \"\"\"\n    super().__init__()\n    try:\n        assert n_points &gt;= 2\n    except AssertionError:\n        raise ValueError(\"You need a minimum of two points to make a line!\")\n\n    if not isinstance(tilt, Iterable):\n        tilt = [tilt]\n\n    x, y, z = line3d(x_start, y_start, z_start, x_stop, y_stop, z_stop, n_points)\n    for i in range(n_points):\n        for t in tilt:\n            self.append(PathElement(x[i], y[i], z[i], pan, t, exact_pose=False))\n</code></pre>"},{"location":"reference/plantimager/path/#plantimager.path.Path","title":"<code>Path()</code>","text":"<p>             Bases: <code>list</code></p> <p>A path is an abstract class that should be a list of <code>PathElement</code> instances.</p> Source code in <code>plantimager/path.py</code> <pre><code>def __init__(self):\n    super().__init__()\n</code></pre>"},{"location":"reference/plantimager/path/#plantimager.path.PathElement","title":"<code>PathElement(x=None, y=None, z=None, pan=None, tilt=None, exact_pose=True)</code>","text":"<p>             Bases: <code>Pose</code></p> <p>Singleton for a <code>Path</code> class.</p> See Also <p>plantimager.path.Pose</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from plantimager.path import PathElement\n&gt;&gt;&gt; elt = PathElement(50, 250, 80, 270, 0, True)\n&gt;&gt;&gt; print(elt)\nx: 50, y: 250, z: 80, pan: 270, tilt: 0, exact_pose: True\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>length_mm</code> <p>Relative distance, in millimeters, to the origin along the x-axis.</p> <code>None</code> <code>y</code> <code>length_mm</code> <p>Relative distance, in millimeters, to the origin along the y-axis.</p> <code>None</code> <code>z</code> <code>length_mm</code> <p>Relative distance, in millimeters, to the origin along the z-axis.</p> <code>None</code> <code>pan</code> <code>deg</code> <p>Relative rotation, in degrees, to the origin along the xy-plane.</p> <code>None</code> <code>tilt</code> <code>deg</code> <p>Relative rotation, in degrees, to the origin along the xy-plane.</p> <code>None</code> <code>exact_pose</code> <code>bool</code> <p>If <code>True</code>, the above parameter values are exact, else they are approximations.</p> <code>True</code> Source code in <code>plantimager/path.py</code> <pre><code>def __init__(self, x=None, y=None, z=None, pan=None, tilt=None, exact_pose=True):\n    \"\"\"\n    Parameters\n    ----------\n    x : length_mm, optional\n        Relative distance, in millimeters, to the origin along the x-axis.\n    y : length_mm, optional\n        Relative distance, in millimeters, to the origin along the y-axis.\n    z : length_mm, optional\n        Relative distance, in millimeters, to the origin along the z-axis.\n    pan : deg, optional\n        Relative rotation, in degrees, to the origin along the xy-plane.\n    tilt : deg, optional\n        Relative rotation, in degrees, to the origin along the xy-plane.\n    exact_pose : bool, optional\n        If ``True``, the above parameter values are exact, else they are approximations.\n\n    \"\"\"\n    super().__init__(x, y, z, pan, tilt)\n    self.exact_pose = exact_pose\n</code></pre>"},{"location":"reference/plantimager/path/#plantimager.path.Pose","title":"<code>Pose(x=None, y=None, z=None, pan=None, tilt=None)</code>","text":"<p>             Bases: <code>object</code></p> <p>Abstract representation of a 'camera pose' as its 5D coordinates.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from plantimager.path import Pose\n&gt;&gt;&gt; p = Pose(50, 250, 80, 270, 0)\n&gt;&gt;&gt; print(p)\nx: 50, y: 250, z: 80, pan: 270, tilt: 0\n</code></pre> <p>Pose constructor.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>length_mm</code> <p>Relative distance to the origin along the x-axis.</p> <code>None</code> <code>y</code> <code>length_mm</code> <p>Relative distance to the origin along the y-axis.</p> <code>None</code> <code>z</code> <code>length_mm</code> <p>Relative distance to the origin along the z-axis.</p> <code>None</code> <code>pan</code> <code>deg</code> <p>Relative rotation to the origin along the xy-plane.</p> <code>None</code> <code>tilt</code> <code>deg</code> <p>Relative rotation to the origin orthogonal to the xy-plane.</p> <code>None</code> Source code in <code>plantimager/path.py</code> <pre><code>def __init__(self, x=None, y=None, z=None, pan=None, tilt=None):\n    \"\"\"Pose constructor.\n\n    Parameters\n    ----------\n    x : length_mm, optional\n        Relative distance to the origin along the x-axis.\n    y : length_mm, optional\n        Relative distance to the origin along the y-axis.\n    z : length_mm, optional\n        Relative distance to the origin along the z-axis.\n    pan : deg, optional\n        Relative rotation to the origin along the xy-plane.\n    tilt : deg, optional\n        Relative rotation to the origin orthogonal to the xy-plane.\n    \"\"\"\n    self.x = x\n    self.y = y\n    self.z = z\n    self.pan = pan\n    self.tilt = tilt\n</code></pre>"},{"location":"reference/plantimager/path/#plantimager.path.circle","title":"<code>circle(center_x, center_y, radius, n_points)</code>","text":"<p>Create a 2D circle of N points with given center and radius.</p> <p>Pan orientations are also computed to always face the center of the circle.</p> <p>Parameters:</p> Name Type Description Default <code>center_x</code> <code>length_mm</code> <p>Relative position of the circle center along the X-axis.</p> required <code>center_y</code> <code>length_mm</code> <p>Relative position of the circle center along the Y-axis.</p> required <code>radius</code> <code>length_mm</code> <p>Radius of the circle to create.</p> required <code>n_points</code> <code>int</code> <p>Number of points used to create the circle.</p> required <p>Returns:</p> Type Description <code>list of length_mm</code> <p>Sequence of x positions.</p> <code>list of length_mm</code> <p>Sequence of y positions.</p> <code>list of deg</code> <p>Sequence of pan orientations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from plantimager.path import circle\n&gt;&gt;&gt; x, y, p = circle(0, 0, 5, 5)\n&gt;&gt;&gt; list(zip(x, y, p))  # to get set of 2D coordinates (x, y) and associated pan.\n[(-5.0, 0.0, 270.0),\n (-1.5450849718747373, -4.755282581475767, 342.0),\n (4.045084971874736, -2.9389262614623664, 54.0),\n (4.045084971874738, 2.938926261462365, 126.0),\n (-1.5450849718747361, 4.755282581475768, 198.0)]\n</code></pre> Source code in <code>plantimager/path.py</code> <pre><code>def circle(center_x, center_y, radius, n_points):\n    \"\"\"Create a 2D circle of N points with given center and radius.\n\n    Pan orientations are also computed to always face the center of the circle.\n\n    Parameters\n    ----------\n    center_x : length_mm\n        Relative position of the circle center along the X-axis.\n    center_y : length_mm\n        Relative position of the circle center along the Y-axis.\n    radius : length_mm\n        Radius of the circle to create.\n    n_points : int\n        Number of points used to create the circle.\n\n    Returns\n    -------\n    list of length_mm\n        Sequence of x positions.\n    list of length_mm\n        Sequence of y positions.\n    list of deg\n        Sequence of pan orientations.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from plantimager.path import circle\n    &gt;&gt;&gt; x, y, p = circle(0, 0, 5, 5)\n    &gt;&gt;&gt; list(zip(x, y, p))  # to get set of 2D coordinates (x, y) and associated pan.\n    [(-5.0, 0.0, 270.0),\n     (-1.5450849718747373, -4.755282581475767, 342.0),\n     (4.045084971874736, -2.9389262614623664, 54.0),\n     (4.045084971874738, 2.938926261462365, 126.0),\n     (-1.5450849718747361, 4.755282581475768, 198.0)]\n\n    \"\"\"\n    x, y, p = [], [], []\n    for i in range(n_points):\n        pan = 2 * i * math.pi / n_points\n        x.append(center_x - radius * math.cos(pan))\n        y.append(center_y - radius * math.sin(pan))\n        pan = pan * 180 / math.pi\n        p.append((pan - 90) % 360)\n\n    return x, y, p\n</code></pre>"},{"location":"reference/plantimager/path/#plantimager.path.line1d","title":"<code>line1d(start, stop, n_points)</code>","text":"<p>Create a 1D line of N points between start and stop position (included).</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>length_mm</code> <p>Line starting position, in millimeters.</p> required <code>stop</code> <code>length_mm</code> <p>Line ending position, in millimeters.</p> required <code>n_points</code> <code>int</code> <p>Number of points used to create the line of points.</p> required <p>Returns:</p> Type Description <code>list of length_mm</code> <p>Sequence of 1D positions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from plantimager.path import line1d\n&gt;&gt;&gt; line1d(0, 10, n_points=5)\n[0.0, 2.5, 5.0, 7.5, 10.0]\n</code></pre> Source code in <code>plantimager/path.py</code> <pre><code>def line1d(start, stop, n_points):\n    \"\"\"Create a 1D line of N points between start and stop position (included).\n\n    Parameters\n    ----------\n    start : length_mm\n        Line starting position, in millimeters.\n    stop : length_mm\n        Line ending position, in millimeters.\n    n_points : int\n        Number of points used to create the line of points.\n\n    Returns\n    -------\n    list of length_mm\n        Sequence of 1D positions.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from plantimager.path import line1d\n    &gt;&gt;&gt; line1d(0, 10, n_points=5)\n    [0.0, 2.5, 5.0, 7.5, 10.0]\n\n    \"\"\"\n    return [(1 - i / (n_points - 1)) * start + (i / (n_points - 1)) * stop for i in range(n_points)]\n</code></pre>"},{"location":"reference/plantimager/path/#plantimager.path.line3d","title":"<code>line3d(x_start, y_start, z_start, x_stop, y_stop, z_stop, n_points)</code>","text":"<p>Create a 3D line of N points between start and stop position (included).</p> <p>Parameters:</p> Name Type Description Default <code>x_start</code> <code>length_mm</code> <p>Line starting position, in millimeters, for the x-axis.</p> required <code>y_start</code> <code>length_mm</code> <p>Line starting position, in millimeters, for the y-axis.</p> required <code>z_start</code> <code>length_mm</code> <p>Line starting position, in millimeters, for the z-axis.</p> required <code>x_stop</code> <code>length_mm</code> <p>Line ending position, in millimeters, for the x-axis.</p> required <code>y_stop</code> <code>length_mm</code> <p>Line ending position, in millimeters, for the y-axis.</p> required <code>z_stop</code> <code>length_mm</code> <p>Line ending position, in millimeters, for the z-axis.</p> required <code>n_points</code> <code>int</code> <p>Number of points used to create the linear path.</p> required <p>Returns:</p> Type Description <code>list of length_mm</code> <p>Sequence of x positions.</p> <code>list of length_mm</code> <p>Sequence of y positions.</p> <code>list of length_mm</code> <p>Sequence of z positions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from plantimager.path import line3d\n&gt;&gt;&gt; line3d(0, 0, 0, 10, 10, 10, n_points=5)\n([0.0, 2.5, 5.0, 7.5, 10.0],\n [0.0, 2.5, 5.0, 7.5, 10.0],\n [0.0, 2.5, 5.0, 7.5, 10.0])\n</code></pre> Source code in <code>plantimager/path.py</code> <pre><code>def line3d(x_start, y_start, z_start, x_stop, y_stop, z_stop, n_points):\n    \"\"\"Create a 3D line of N points between start and stop position (included).\n\n    Parameters\n    ----------\n    x_start : length_mm\n        Line starting position, in millimeters, for the x-axis.\n    y_start : length_mm\n        Line starting position, in millimeters, for the y-axis.\n    z_start : length_mm\n        Line starting position, in millimeters, for the z-axis.\n    x_stop : length_mm\n        Line ending position, in millimeters, for the x-axis.\n    y_stop : length_mm\n        Line ending position, in millimeters, for the y-axis.\n    z_stop : length_mm\n        Line ending position, in millimeters, for the z-axis.\n    n_points : int\n        Number of points used to create the linear path.\n\n    Returns\n    -------\n    list of length_mm\n        Sequence of x positions.\n    list of length_mm\n        Sequence of y positions.\n    list of length_mm\n        Sequence of z positions.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from plantimager.path import line3d\n    &gt;&gt;&gt; line3d(0, 0, 0, 10, 10, 10, n_points=5)\n    ([0.0, 2.5, 5.0, 7.5, 10.0],\n     [0.0, 2.5, 5.0, 7.5, 10.0],\n     [0.0, 2.5, 5.0, 7.5, 10.0])\n\n    \"\"\"\n    return line1d(x_start, x_stop, n_points), line1d(y_start, y_stop, n_points), line1d(z_start, z_stop, n_points)\n</code></pre>"},{"location":"reference/plantimager/scanner/","title":"scanner","text":""},{"location":"reference/plantimager/scanner/#plantimager.scanner.Scanner","title":"<code>Scanner(cnc, gimbal, camera, waiting_time=1.0)</code>","text":"<p>             Bases: <code>AbstractScanner</code></p> <p>The Scanner class to combine control of CNC, Gimbal &amp; Camera.</p> <p>Attributes:</p> Name Type Description <code>cnc</code> <code>AbstractCNC</code> <p>A class dedicated to CNC control.</p> <code>gimbal</code> <code>AbstractGimbal</code> <p>A class dedicated to Gimbal control.</p> <code>camera</code> <code>AbstractCamera</code> <p>A class dedicated to Camera control.</p> <code>waiting_time</code> <code>(float, optional)</code> <p>The time, in seconds, to wait for stabilization after setting position, default is 1.</p> See Also <p>plantimager.hal.AbstractScanner</p> Example <p>from plantimager.scanner import Scanner</p> <p>Scanner constructor.</p> <p>Parameters:</p> Name Type Description Default <code>cnc</code> <code>AbstractCNC</code> <p>A class dedicated to CNC control.</p> required <code>gimbal</code> <p>A class dedicated to Gimbal control.</p> required <code>camera</code> <code>AbstractCamera</code> <p>A class dedicated to Camera control.</p> required <code>waiting_time</code> <p>The time, in seconds, to wait for stabilization after setting position, default is 1.</p> <code>1.0</code> Source code in <code>plantimager/scanner.py</code> <pre><code>def __init__(self, cnc, gimbal, camera, waiting_time=1.):\n    \"\"\"Scanner constructor.\n\n    Parameters\n    ----------\n    cnc : plantimager.hal.AbstractCNC\n        A class dedicated to CNC control.\n    gimbal: plantimager.hal.AbstractGimbal\n        A class dedicated to Gimbal control.\n    camera : plantimager.hal.AbstractCamera\n        A class dedicated to Camera control.\n    waiting_time: float, optional\n        The time, in seconds, to wait for stabilization after setting position, default is 1.\n    \"\"\"\n    super().__init__()\n    self.cnc = cnc\n    self.gimbal = gimbal\n    self.camera = camera\n    self.waiting_time = waiting_time  # time to wait for stabilization after setting position\n</code></pre>"},{"location":"reference/plantimager/scanner/#plantimager.scanner.Scanner--example-1-a-dummy-scanner","title":"Example #1 - A dummy scanner","text":"<p>from plantimager.dummy import CNC from plantimager.dummy import Gimbal from plantimager.dummy import Camera cnc = CNC() gimbal = Gimbal() camera = Camera() dummy_scanner = Scanner(cnc, gimbal, camera)</p>"},{"location":"reference/plantimager/scanner/#plantimager.scanner.Scanner--example-2-a-scanner-with-cnc-gimbal-connected-via-usb-and-an-url-camera","title":"Example #2 - A scanner with CNC &amp; Gimbal connected via USB and an URL Camera","text":"<p>from plantimager.grbl import CNC from plantimager.blgimbal import Gimbal from plantimager.urlcam import Camera cnc = CNC(\"/dev/ttyACM0\", x_lims=[0, 800], y_lims=[0, 800], z_lims=[0, 100]) gimbal = Gimbal(\"/dev/ttyACM1\", has_tilt=False, invert_rotation=True) camera = Camera(\"http://192.168.0.1:8080\") scanner = Scanner(cnc, gimbal, camera)</p>"},{"location":"reference/plantimager/scanner/#plantimager.scanner.Scanner.channels","title":"<code>channels()</code>","text":"<p>Channel names associated to grabbed data with the grab method.</p> <p>Returns:</p> Type Description <code>List of str</code> <p>The list of channel names.</p> See Also <p>plantimager.hal.AbstractCamera</p> Source code in <code>plantimager/scanner.py</code> <pre><code>def channels(self):\n    \"\"\"Channel names associated to grabbed data with the grab method.\n\n    Returns\n    -------\n    List of str\n        The list of channel names.\n\n    See Also\n    --------\n    plantimager.hal.AbstractCamera\n    \"\"\"\n    return self.camera.channels()\n</code></pre>"},{"location":"reference/plantimager/scanner/#plantimager.scanner.Scanner.get_position","title":"<code>get_position()</code>","text":"<p>Get the current position of the scanner as a 5D Pose.</p> Source code in <code>plantimager/scanner.py</code> <pre><code>def get_position(self) -&gt; Pose:\n    \"\"\"Get the current position of the scanner as a 5D Pose.\"\"\"\n    x, y, z = self.cnc.get_position()\n    pan, tilt = self.gimbal.get_position()\n    return Pose(x, y, z, pan, tilt)\n</code></pre>"},{"location":"reference/plantimager/scanner/#plantimager.scanner.Scanner.grab","title":"<code>grab(idx, metadata=None)</code>","text":"<p>Grab data with an id and metadata.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Id of the data <code>DataItem</code> to create.</p> required <code>metadata</code> <code>dict</code> <p>Dictionary of metadata associated to the camera data.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataItem</code> <p>The image data.</p> See Also <p>plantimager.hal.AbstractCamera plantimager.hal.AbstractScanner</p> Source code in <code>plantimager/scanner.py</code> <pre><code>def grab(self, idx, metadata=None):\n    \"\"\"Grab data with an id and metadata.\n\n    Parameters\n    ----------\n    idx : int\n        Id of the data `DataItem` to create.\n    metadata : dict, optional\n        Dictionary of metadata associated to the camera data.\n\n    Returns\n    -------\n    plantimager.hal.DataItem\n        The image data.\n\n    See Also\n    --------\n    plantimager.hal.AbstractCamera\n    plantimager.hal.AbstractScanner\n    \"\"\"\n    return self.camera.grab(idx, metadata)\n</code></pre>"},{"location":"reference/plantimager/scanner/#plantimager.scanner.Scanner.set_position","title":"<code>set_position(pose)</code>","text":"<p>Set the position of the scanner from a 5D Pose.</p> <p>The stabilization waiting time is done at the end of this step.</p> Source code in <code>plantimager/scanner.py</code> <pre><code>def set_position(self, pose: Pose) -&gt; None:\n    \"\"\"Set the position of the scanner from a 5D Pose.\n\n    The _stabilization waiting time_ is done at the end of this step.\n    \"\"\"\n    if self.cnc.async_enabled():\n        self.cnc.moveto_async(pose.x, pose.y, pose.z)\n        self.gimbal.moveto_async(pose.pan, pose.tilt)\n        self.cnc.wait()\n        self.gimbal.wait()\n    else:\n        self.cnc.moveto(pose.x, pose.y, pose.z)\n        self.gimbal.moveto(pose.pan, pose.tilt)\n    time.sleep(self.waiting_time)\n    return\n</code></pre>"},{"location":"reference/plantimager/sony/","title":"sony","text":""},{"location":"reference/plantimager/sony/#plantimager.sony.Camera","title":"<code>Camera(device_ip, api_port, timeout=10, postview=False, use_adb=False, use_flashair=False, flashair_host=None, camera_params=None, rotation=0)</code>","text":"<p>             Bases: <code>AbstractCamera</code></p> <p>Sony Remote Control API.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from plantimager.sony import Camera\n&gt;&gt;&gt; cam = Camera('192.168.122.1', '10000', postview=True, rotation=0)\n&gt;&gt;&gt; img = cam.grab(0)\n&gt;&gt;&gt; arr = img.channels['rgb'].data\n&gt;&gt;&gt; arr.shape\n</code></pre> <pre><code>&gt;&gt;&gt; cam = Camera('192.168.122.1', '10000', postview=True, rotation=270)\n&gt;&gt;&gt; img = cam.grab(0)\n&gt;&gt;&gt; arr = np.array(img.channels['rgb'].data)\n&gt;&gt;&gt; arr.shape\n</code></pre> Source code in <code>plantimager/sony.py</code> <pre><code>def __init__(self, device_ip: str,\n             api_port: str,\n             timeout: time_s = 10,\n             postview: bool = False,\n             use_adb: bool = False,\n             use_flashair: bool = False,\n             flashair_host: str = None,\n             camera_params: dict = None,\n             rotation: int = 0):\n\n    self.sony_cam = SonyCamAPI(device_ip, api_port, timeout=timeout)\n    self.postview = postview\n    self.use_flashair = use_flashair\n    self.use_adb = use_adb\n    if use_flashair and use_adb:\n        raise SonyCamError(\"Cannot use both flashair and adb for transfer\")\n    if use_flashair:\n        if flashair_host is None:\n            raise SonyCamError(\"Must provide flashair host IP\")\n        self.flashair = FlashAirAPI(flashair_host)\n\n    self.camera_params = camera_params\n    self.rotation = rotation  # degrees counter-clockwise\n    self.start()\n</code></pre>"},{"location":"reference/plantimager/sony/#plantimager.sony.SonyCamAPI","title":"<code>SonyCamAPI(device_ip, api_port, timeout=2)</code>","text":"<p>             Bases: <code>object</code></p> Source code in <code>plantimager/sony.py</code> <pre><code>def __init__(self, device_ip, api_port, timeout=2):\n    self.device_ip = device_ip\n    self.api_port = api_port\n    self.api_url = 'http://' + device_ip + ':' + api_port + '/sony/'\n    self.timeout = timeout\n    method_types = self.get_method_types()\n    self.supported_methods = [x[0] for x in method_types]\n</code></pre>"},{"location":"reference/plantimager/sony/#plantimager.sony.SonyCamAPI.adb_transfer_pictures","title":"<code>adb_transfer_pictures(count=1)</code>","text":"<p>Transfer the latest count pictures from the camera ADB shell must be enabled on the camera</p> Source code in <code>plantimager/sony.py</code> <pre><code>def adb_transfer_pictures(self, count=1):\n    \"\"\"\n    Transfer the latest count pictures from the camera\n    ADB shell must be enabled on the camera\n    \"\"\"\n    subprocess.run(['adb', 'connect', self.device_ip])\n    x = subprocess.run(['adb', 'shell', 'ls /sdcard/DCIM/100MSDCF'], capture_output=True)\n    files = x.stdout.split()\n    files = list(map(lambda x: x.decode(), files))\n    files.sort()\n    files = files[-count:]\n    images = []\n    for f in files:\n        subprocess.run(['adb', 'pull', '/sdcard/DCIM/100MSDCF/' + f, '/tmp/'])\n        im = imageio.imread('/tmp/' + f)\n        images.append(im)\n        print(f)\n    return images\n</code></pre>"},{"location":"reference/plantimager/units/","title":"units","text":""},{"location":"reference/plantimager/urlcam/","title":"urlcam","text":""},{"location":"reference/plantimager/urlcam/#plantimager.urlcam.Camera","title":"<code>Camera(url)</code>","text":"<p>             Bases: <code>AbstractCamera</code></p> <p>Camera module fetching an image serve at given URL.</p> Notes <p>Image should be served as <code>$url/scan.jpg</code>.</p> See Also <p>plantimager.hal.AbstractCamera</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from plantimager.urlcam import Camera\n&gt;&gt;&gt; url = \"http://192.168.0.1:8080\"\n&gt;&gt;&gt; cam = Camera(url)\n&gt;&gt;&gt; img = cam.grab(\"img_001\")\n&gt;&gt;&gt; arr = img.channel(\"rgb\").data\n&gt;&gt;&gt; arr.shape\n&gt;&gt;&gt; image = Image.fromarray(arr)\n&gt;&gt;&gt; image.show()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the camera.</p> required Source code in <code>plantimager/urlcam.py</code> <pre><code>def __init__(self, url):\n    \"\"\"\n    Parameters\n    ----------\n    url : str\n        URL of the camera.\n    \"\"\"\n    self.url = url\n</code></pre>"},{"location":"reference/plantimager/urlcam/#plantimager.urlcam.Camera.grab","title":"<code>grab(idx, metadata=None)</code>","text":"<p>Grab a picture from the camera.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Id of the image <code>DataItem</code> to create.</p> required <code>metadata</code> <code>dict</code> <p>Dictionary of metadata associated to the picture.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataItem</code> <p>The image data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from plantimager.urlcam import Camera\n&gt;&gt;&gt; url = \"http://192.168.0.1:8080\"\n&gt;&gt;&gt; cam = Camera(url)\n&gt;&gt;&gt; img = cam.grab(\"img_001\")\n&gt;&gt;&gt; arr = img.channel(\"rgb\").data\n</code></pre> <pre><code>&gt;&gt;&gt; from PIL import Image\n&gt;&gt;&gt; image = Image.fromarray(arr)\n&gt;&gt;&gt; image.show()\n</code></pre> Source code in <code>plantimager/urlcam.py</code> <pre><code>def grab(self, idx: int, metadata: dict = None):\n    \"\"\"Grab a picture from the camera.\n\n    Parameters\n    ----------\n    idx : int\n        Id of the image `DataItem` to create.\n    metadata : dict, optional\n        Dictionary of metadata associated to the picture.\n\n    Returns\n    -------\n    plantimager.hal.DataItem\n        The image data.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from plantimager.urlcam import Camera\n    &gt;&gt;&gt; url = \"http://192.168.0.1:8080\"\n    &gt;&gt;&gt; cam = Camera(url)\n    &gt;&gt;&gt; img = cam.grab(\"img_001\")\n    &gt;&gt;&gt; arr = img.channel(\"rgb\").data\n\n    &gt;&gt;&gt; from PIL import Image\n    &gt;&gt;&gt; image = Image.fromarray(arr)\n    &gt;&gt;&gt; image.show()\n\n    \"\"\"\n    data_item = DataItem(idx, metadata)\n    # https://docs.python.org/3/library/http.server.html#http.server.BaseHTTPRequestHandler.wfile\n    # wfile:\n    #   Contains the output stream for writing a response back to the client.\n    #   Proper adherence to the HTTP protocol must be used when writing to this stream in order to achieve successful interoperation with HTTP clients.\n    #   Changed in version 3.6: This is an io.BufferedIOBase stream.\n    # data = imageio.imread(BytesIO(requests.get(self.url+\"scan.jpg\").content))\n    # _ = requests.get(self.url + \"/scan.jpg\")  # update the picture\n    data = imageio.imread(self.url + \"/scan.jpg\")  # download it\n    data_item.add_channel(self.channels()[0], data)\n    return data_item\n</code></pre>"},{"location":"reference/plantimager/utils/","title":"utils","text":"<p>A collection of various utilities.</p>"},{"location":"reference/plantimager/utils/#plantimager.utils.guess_port","title":"<code>guess_port(info)</code>","text":"<p>Guess the USB port using a given information.</p> <p>Parameters:</p> Name Type Description Default <code>info</code> <code>str</code> <p>The information to use to search ports.</p> required Notes <p>Search for ports using a regular expression. Port <code>name</code>, <code>description</code> and <code>hwid</code> are searched (case insensitive). The function returns an iterable that contains the same data that comports() generates, but includes only those entries that match the regexp.</p> See Also <p>serial.tools.list_ports.grep</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from plantimager.utils import guess_port\n&gt;&gt;&gt; guess_port(\"A\")  # This should yield a \"More than one serial device\" error...\n&gt;&gt;&gt; guess_port(\"007\")  # This should yield a \"No serial device\" error...\n&gt;&gt;&gt; guess_port(\"Arduino\")  # This should return the port of the CNC (if using the X-Carve as the controller is based on an Arduino UNO)\n</code></pre> Source code in <code>plantimager/utils.py</code> <pre><code>def guess_port(info):\n    \"\"\"Guess the USB port using a given information.\n\n    Parameters\n    ----------\n    info : str\n        The information to use to search ports.\n\n    Notes\n    -----\n    Search for ports using a regular expression. Port ``name``, ``description`` and ``hwid`` are searched (case insensitive).\n    The function returns an iterable that contains the same data that comports() generates, but includes only those entries that match the regexp.\n\n    See Also\n    --------\n    serial.tools.list_ports.grep\n\n    Examples\n    --------\n    &gt;&gt;&gt; from plantimager.utils import guess_port\n    &gt;&gt;&gt; guess_port(\"A\")  # This should yield a \"More than one serial device\" error...\n    &gt;&gt;&gt; guess_port(\"007\")  # This should yield a \"No serial device\" error...\n    &gt;&gt;&gt; guess_port(\"Arduino\")  # This should return the port of the CNC (if using the X-Carve as the controller is based on an Arduino UNO)\n\n    \"\"\"\n    device = [p for p in list(list_ports.grep(info))]\n    if len(device) &gt; 1:\n        logger.warning(f\"More than one serial device has been found with '{info}'!\")\n        [logger.warning(f\"  * {dev.device} - {dev.description} - {dev.hwid}\") for dev in device]\n        sys.exit(\"Non unique serial device ID!\")\n    elif len(device) == 0:\n        logger.warning(f\"No serial device has been found with '{info}'!\")\n        sys.exit(\"No serial device found!\")\n    else:\n        device = device[0]\n\n    return device.device\n</code></pre>"},{"location":"reference/plantimager/utils/#plantimager.utils.now","title":"<code>now(fmt='%Y-%m-%d %H:%M:%S')</code>","text":"<p>Return datetime as a formatted string.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>str</code> <p>The date and time formating to use, default to '%y-%m-%d %H:%M:%S'.</p> <code>'%Y-%m-%d %H:%M:%S'</code> References <p>https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from plantimager.utils import now\n&gt;&gt;&gt; now()\n</code></pre> Source code in <code>plantimager/utils.py</code> <pre><code>def now(fmt=\"%Y-%m-%d %H:%M:%S\"):\n    \"\"\"Return datetime as a formatted string.\n\n    Parameters\n    ----------\n    fmt : str, optional\n        The date and time formating to use, default to '%y-%m-%d %H:%M:%S'.\n\n    References\n    ----------\n    https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes\n\n    Examples\n    --------\n    &gt;&gt;&gt; from plantimager.utils import now\n    &gt;&gt;&gt; now()\n    \"\"\"\n    return datetime.datetime.now().strftime(fmt)\n</code></pre>"},{"location":"reference/plantimager/vscan/","title":"vscan","text":""},{"location":"reference/plantimager/vscan/#plantimager.vscan.VirtualScanner","title":"<code>VirtualScanner(width, height, focal, flash=False, host=None, port=9001, scene=None, add_leaf_displacement=False, classes=None)</code>","text":"<p>             Bases: <code>AbstractScanner</code></p> <p>A virtual scanner sending HTTP requests to a host rendering the 3D virtual plant and taking pictures.</p> <p>Attributes:</p> Name Type Description <code>runner</code> <code>VirtualScannerRunner</code> <p>The runner for the virtual scanner process. It must accept POST &amp; GET HTTP requests.</p> <code>host</code> <code>str</code> <p>The virtual scanner host ip.</p> <code>port</code> <code>int</code> <p>The virtual scanner host port.</p> <code>classes</code> <code>list of str</code> <p>The list of classes to render, must be found in the loaded OBJ.</p> <code>flash</code> <code>bool</code> <p>If <code>True</code>, light the scene with a flash.</p> <code>ext</code> <code>str</code> <p>Extension to use to write image data from the <code>grab</code> method.</p> <code>position</code> <code>Pose</code> <p>The current position of the camera.</p> <code>add_leaf_displacement</code> <code>bool</code> <p>If <code>True</code>, add a random displacement to the leaf class objects after loading the virtual plant.</p> <p>Instantiate a <code>VirtualScanner</code>.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the image to acquire.</p> required <code>height</code> <code>int</code> <p>The height of the image to acquire.</p> required <code>focal</code> <code>int</code> <p>The focal distance to the object to acquire.</p> required <code>flash</code> <code>bool</code> <p>If <code>True</code>, light the scene with a flash. Defaults to <code>False</code>.</p> <code>False</code> <code>host</code> <code>str</code> <p>The virtual scanner host ip. By default, instantiate a local <code>VirtualScannerRunner</code> process.</p> <code>None</code> <code>port</code> <code>int</code> <p>The virtual scanner host port. Used only if <code>host</code> is NOT set. Defaults to <code>5000</code>.</p> <code>9001</code> <code>scene</code> <code>str</code> <p>Path to the scene file to create in the  <code>VirtualScannerRunner</code>. Used only if <code>host</code> is NOT set.</p> <code>None</code> <code>add_leaf_displacement</code> <code>bool</code> <p>If <code>True</code>, add a random displacement to the leaf class objects after loading the virtual plant. Defaults to <code>False</code>.</p> <code>False</code> <code>classes</code> <code>list of str</code> <p>The list of classes to generate pictures for, must be found in the loaded OBJ. Defaults to <code>None</code>.</p> <code>None</code> Source code in <code>plantimager/vscan.py</code> <pre><code>def __init__(self, width, height, focal, flash=False, host=None, port=9001, scene=None,\n             add_leaf_displacement=False, classes=None):\n    \"\"\"Instantiate a ``VirtualScanner``.\n\n    Parameters\n    ----------\n    width : int\n        The width of the image to acquire.\n    height : int\n        The height of the image to acquire.\n    focal : int\n        The focal distance to the object to acquire.\n    flash : bool, optional\n        If ``True``, light the scene with a flash.\n        Defaults to ``False``.\n    host : str, optional\n        The virtual scanner host ip.\n        By default, instantiate a local ``VirtualScannerRunner`` process.\n    port : int, optional\n        The virtual scanner host port.\n        Used only if ``host`` is NOT set.\n        Defaults to ``5000``.\n    scene : str, optional\n        Path to the scene file to create in the  ``VirtualScannerRunner``.\n        Used only if ``host`` is NOT set.\n    add_leaf_displacement : bool, optional\n        If ``True``, add a random displacement to the leaf class objects after loading the virtual plant.\n        Defaults to ``False``.\n    classes : list of str, optional\n        The list of classes to generate pictures for, must be found in the loaded OBJ.\n        Defaults to ``None``.\n    \"\"\"\n    super().__init__()\n\n    if host is None:\n        self.runner = VirtualScannerRunner(scene=scene, port=port)\n        self.runner.start()\n        self.host = \"localhost\"\n        self.port = self.runner.port\n    else:\n        self.runner = None\n        self.host = host\n        self.port = port\n\n    self.classes = classes\n    self.flash = flash\n    self.set_intrinsics(width, height, focal)\n    self.ext = \"png\"\n    self.position = path.Pose()\n    self.add_leaf_displacement = add_leaf_displacement\n    if self.add_leaf_displacement:\n        logger.warning(\"Random leaf displacement has been requested!\")\n</code></pre>"},{"location":"reference/plantimager/vscan/#plantimager.vscan.VirtualScanner.channels","title":"<code>channels()</code>","text":"<p>List the channels to acquire.</p> Notes <p>Default to the 'rgb' channel. If classes are defined, they will be returned in addition to the default and the 'background'.</p> Source code in <code>plantimager/vscan.py</code> <pre><code>def channels(self) -&gt; list:\n    \"\"\"List the channels to acquire.\n\n    Notes\n    -----\n    Default to the 'rgb' channel.\n    If classes are defined, they will be returned in addition to the default and the 'background'.\n    \"\"\"\n    if self.classes is None:\n        return ['rgb']\n    else:\n        return ['rgb'] + self.classes + ['background']\n</code></pre>"},{"location":"reference/plantimager/vscan/#plantimager.vscan.VirtualScanner.get_bounding_box","title":"<code>get_bounding_box()</code>","text":"<p>Returns the bounding-box coordinates from the Blender server.</p> Source code in <code>plantimager/vscan.py</code> <pre><code>def get_bounding_box(self):\n    \"\"\"Returns the bounding-box coordinates from the Blender server.\"\"\"\n    return self.request_get_dict(\"bounding_box\")\n</code></pre>"},{"location":"reference/plantimager/vscan/#plantimager.vscan.VirtualScanner.get_position","title":"<code>get_position()</code>","text":"<p>Returns the current position of the camera.</p> Source code in <code>plantimager/vscan.py</code> <pre><code>def get_position(self) -&gt; path.Pose:\n    \"\"\"Returns the current position of the camera.\"\"\"\n    return self.position\n</code></pre>"},{"location":"reference/plantimager/vscan/#plantimager.vscan.VirtualScanner.grab","title":"<code>grab(idx, metadata=None)</code>","text":"<p>Grab a picture using the virtual scanner.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The id of the picture.</p> required <code>metadata</code> <code>dict</code> <p>The dictionary of metadata to associate to this picture.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataItem</code> <p>The picture data &amp; metadata.</p> Source code in <code>plantimager/vscan.py</code> <pre><code>def grab(self, idx: int, metadata: dict = None) -&gt; DataItem:\n    \"\"\"Grab a picture using the virtual scanner.\n\n    Parameters\n    ----------\n    idx : int\n        The id of the picture.\n    metadata : dict, optional\n        The dictionary of metadata to associate to this picture.\n\n    Returns\n    -------\n    plantimager.hal.DataItem\n        The picture data &amp; metadata.\n    \"\"\"\n    data_item = DataItem(idx, metadata)\n    for c in self.channels():\n        if c != 'background':\n            data_item.add_channel(c, self.render(channel=c))\n\n    if 'background' in self.channels():\n        # Generate the background:\n        bg_mask = np.zeros_like(data_item.channel(self.classes[0]).data, dtype=np.uint8)\n        for c in self.classes:\n            mask = data_item.channel(c).data\n            bg_mask = np.maximum(bg_mask, mask)\n        bg_mask = 255 - bg_mask\n        data_item.add_channel(\"background\", bg_mask)\n\n    if metadata is None:\n        metadata = {}\n\n    metadata[\"camera\"] = {\n        \"camera_model\": self.request_get_dict(\"camera_intrinsics\"),\n        **self.request_get_dict(\"camera_pose\")\n    }\n    return data_item\n</code></pre>"},{"location":"reference/plantimager/vscan/#plantimager.vscan.VirtualScanner.list_backgrounds","title":"<code>list_backgrounds()</code>","text":"<p>List the available backgrounds.</p> Source code in <code>plantimager/vscan.py</code> <pre><code>def list_backgrounds(self):\n    \"\"\"List the available backgrounds.\"\"\"\n    return self.request_get_dict(\"backgrounds\")\n</code></pre>"},{"location":"reference/plantimager/vscan/#plantimager.vscan.VirtualScanner.list_objects","title":"<code>list_objects()</code>","text":"<p>List the available objects.</p> Source code in <code>plantimager/vscan.py</code> <pre><code>def list_objects(self):\n    \"\"\"List the available objects.\"\"\"\n    return self.request_get_dict(\"objects\")\n</code></pre>"},{"location":"reference/plantimager/vscan/#plantimager.vscan.VirtualScanner.load_background","title":"<code>load_background(file)</code>","text":"<p>Loads a background from a HDRI file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>File</code> <p>The file instance corresponding to the HDRI file.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>The response from Blender Flask server to background file upload.</p> See Also <p>romi_virtualplantimager.upload_background_post</p> Source code in <code>plantimager/vscan.py</code> <pre><code>def load_background(self, file: File):\n    \"\"\"Loads a background from a HDRI file.\n\n    Parameters\n    ----------\n    file : plantdb.FSDB.File\n        The file instance corresponding to the HDRI file.\n\n    Returns\n    -------\n    requests.Response\n        The response from Blender Flask server to background file upload.\n\n    See Also\n    --------\n    romi_virtualplantimager.upload_background_post\n    \"\"\"\n    logger.debug(\"loading background : %s\" % file.filename)\n    with tempfile.TemporaryDirectory() as tmpdir:\n        # Copy the PNG palette file to a temporary directory &amp; get the `BufferedReader` from it, if requested:\n        file_path = os.path.join(tmpdir, file.filename)\n        to_file(file, file_path)\n        files = {\"hdr\": open(file_path, \"rb\")}\n        res = self.request_post(\"upload_background\", {}, files)\n    return res\n</code></pre>"},{"location":"reference/plantimager/vscan/#plantimager.vscan.VirtualScanner.load_object","title":"<code>load_object(file, mtl=None, palette=None, colorize=True)</code>","text":"<p>Upload the OBJ, MTL and palette files to the Blender Flask server with the POST method.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>File</code> <p>The <code>File</code> instance corresponding to the OBJ file.</p> required <code>mtl</code> <code>File</code> <p>The <code>File</code> instance corresponding to the MTL file.</p> <code>None</code> <code>palette</code> <code>File</code> <p>The <code>File</code> instance corresponding to the PNG palette file.</p> <code>None</code> <code>colorize</code> <code>bool</code> <p>Whether the object should be colorized in Blender.</p> <code>True</code> <p>Returns:</p> Type Description <code>Response</code> <p>The response from Blender Flask server after uploading the files.</p> See Also <p>romi_virtualplantimager.upload_object_post</p> Notes <p>To avoid messing up the OBJ, MTL &amp; PNG palette files, we create a temporary copy.</p> <p>The POST method of the Blender Flask server expect:   - a 'file' argument with the <code>BufferedReader</code> for the OBJ file [REQUIRED].   - a 'mtl' argument with the <code>BufferedReader</code> for the MTL file [OPTIONAL].   - a 'palette' argument with the <code>BufferedReader</code> for the PNG palette file [OPTIONAL].   - a 'colorize' argument as boolean [OPTIONAL].</p> Source code in <code>plantimager/vscan.py</code> <pre><code>def load_object(self, file, mtl=None, palette=None, colorize=True):\n    \"\"\"Upload the OBJ, MTL and palette files to the Blender Flask server with the POST method.\n\n    Parameters\n    ----------\n    file : plantdb.FSDB.File\n        The `File` instance corresponding to the OBJ file.\n    mtl : plantdb.FSDB.File, optional\n        The `File` instance corresponding to the MTL file.\n    palette : plantdb.FSDB.File, optional\n        The `File` instance corresponding to the PNG palette file.\n    colorize : bool, optional\n        Whether the object should be colorized in Blender.\n\n    Returns\n    -------\n    requests.Response\n        The response from Blender Flask server after uploading the files.\n\n    See Also\n    --------\n    romi_virtualplantimager.upload_object_post\n\n    Notes\n    -----\n    To avoid messing up the OBJ, MTL &amp; PNG palette files, we create a temporary copy.\n\n    The POST method of the Blender Flask server expect:\n      - a 'file' argument with the `BufferedReader` for the OBJ file [REQUIRED].\n      - a 'mtl' argument with the `BufferedReader` for the MTL file [OPTIONAL].\n      - a 'palette' argument with the `BufferedReader` for the PNG palette file [OPTIONAL].\n      - a 'colorize' argument as boolean [OPTIONAL].\n    \"\"\"\n    # Convert path (str) to `plantdb.FSDB.File` type if necessary (create a temporary FSDB):\n    if isinstance(file, str):\n        file = fsdb_file_from_local_file(file)\n    if isinstance(mtl, str):\n        mtl = fsdb_file_from_local_file(mtl)\n    if isinstance(palette, str):\n        palette = fsdb_file_from_local_file(palette)\n\n    files = {}  # dict of `BufferedReader` to use for upload\n    with tempfile.TemporaryDirectory() as tmpdir:\n        # Copy the OBJ file to a temporary directory &amp; get the `BufferedReader` from it:\n        obj_file_path = os.path.join(tmpdir, file.filename)\n        to_file(file, obj_file_path)\n        files[\"obj\"] = open(obj_file_path, \"rb\")\n        # Copy the MTL file to a temporary directory &amp; get the `BufferedReader` from it, if requested:\n        if mtl is not None:\n            mtl_file_path = os.path.join(tmpdir, mtl.filename)\n            to_file(mtl, mtl_file_path)\n            files[\"mtl\"] = open(mtl_file_path, \"rb\")\n        # Copy the PNG palette file to a temporary directory &amp; get the `BufferedReader` from it, if requested:\n        if palette is not None:\n            palette_file_path = os.path.join(tmpdir, palette.filename)\n            to_file(palette, palette_file_path)\n            files[\"palette\"] = open(palette_file_path, \"rb\")\n        # Upload these files to the Blender Flask server:\n        res = self.request_post(\"upload_object\", {\"colorize\": colorize}, files)\n\n    # Apply random leaf displacement, if requested:\n    if self.add_leaf_displacement:\n        self.request_get_dict(\"add_random_displacement/leaf\")\n\n    return res\n</code></pre>"},{"location":"reference/plantimager/vscan/#plantimager.vscan.VirtualScanner.render","title":"<code>render(channel='rgb')</code>","text":"<p>Use the Blender server to render an image of the virtual plant.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>str</code> <p>The name of the channel to render. If not 'rgb' grab a picture of a specific part of the virtual plant. Defaults to 'rgb', grab a picture of the whole virtual plant.</p> <code>'rgb'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The image array.</p> Source code in <code>plantimager/vscan.py</code> <pre><code>def render(self, channel='rgb'):\n    \"\"\"Use the Blender server to render an image of the virtual plant.\n\n    Parameters\n    ----------\n    channel : str, optional\n        The name of the channel to render.\n        If not 'rgb' grab a picture of a specific part of the virtual plant.\n        Defaults to 'rgb', grab a picture of the whole virtual plant.\n\n    Returns\n    -------\n    numpy.ndarray\n        The image array.\n    \"\"\"\n    if channel == 'rgb':\n        ep = \"render\"\n        if self.flash:\n            ep = ep + \"?flash=1\"\n        x = self.request_get_bytes(ep)\n        data = iio.imread(BytesIO(x))\n        return data\n    else:\n        x = self.request_get_bytes(\"render_class/%s\" % channel)\n        data = iio.imread(BytesIO(x))\n        data = np.array(255 * (data[:, :, 3] &gt; 10), dtype=np.uint8)\n        return data\n</code></pre>"},{"location":"reference/plantimager/vscan/#plantimager.vscan.VirtualScanner.set_intrinsics","title":"<code>set_intrinsics(width, height, focal)</code>","text":"<p>Set the intrinsic parameters of the camera for the virtual scanner.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the image to acquire.</p> required <code>height</code> <code>int</code> <p>The height of the image to acquire.</p> required <code>focal</code> <code>int</code> <p>The focal distance to the object to acquire.</p> required Source code in <code>plantimager/vscan.py</code> <pre><code>def set_intrinsics(self, width: int, height: int, focal: float) -&gt; None:\n    \"\"\"Set the intrinsic parameters of the camera for the virtual scanner.\n\n    Parameters\n    ----------\n    width : int\n        The width of the image to acquire.\n    height : int\n        The height of the image to acquire.\n    focal : int\n        The focal distance to the object to acquire.\n    \"\"\"\n    self.width = width\n    self.height = height\n    self.focal = focal\n    data = {\n        \"width\": width,\n        \"height\": height,\n        \"focal\": focal,\n    }\n    self.request_post(\"camera_intrinsics\", data)\n    return\n</code></pre>"},{"location":"reference/plantimager/vscan/#plantimager.vscan.VirtualScanner.set_position","title":"<code>set_position(pose)</code>","text":"<p>Set the new position of the camera.</p> Source code in <code>plantimager/vscan.py</code> <pre><code>def set_position(self, pose: path.Pose) -&gt; None:\n    \"\"\"Set the new position of the camera.\"\"\"\n    data = {\n        \"rx\": 90 - pose.tilt,\n        \"rz\": pose.pan,\n        \"tx\": pose.x,\n        \"ty\": pose.y,\n        \"tz\": pose.z\n    }\n    self.request_post(\"camera_pose\", data)\n    self.position = pose\n    return\n</code></pre>"},{"location":"reference/plantimager/vscan/#plantimager.vscan.VirtualScannerRunner","title":"<code>VirtualScannerRunner(scene=None, port=9001)</code>","text":"<p>Run a Flask server in Blender to act as the virtual scanner.</p> <p>Attributes:</p> Name Type Description <code>subprocess</code> <code>Popen</code> <p>The subprocess instance, initialized by the <code>start</code> method.</p> <code>scene</code> <code>str</code> <p>Path to a Blender scene file to load.</p> <code>port</code> <code>int</code> <p>The port to use to instantiate and communicate with the Flask server in Blender.</p> Notes <p>It initializes the flask server and then listens to HTTP requests on that port. The process is started with the <code>start()</code> method and stopped with the <code>stop()</code> method.</p> <p>Instantiate a <code>VirtualScannerRunner</code>.</p> <p>Parameters:</p> Name Type Description Default <code>scene</code> <code>str</code> <p>Path to a Blender scene file to load. Defaults to <code>None</code>.</p> <code>None</code> <code>port</code> <code>int</code> <p>The port to use to instantiate and communicate with the Flask server in Blender. Defaults to <code>9001</code>.</p> <code>9001</code> Source code in <code>plantimager/vscan.py</code> <pre><code>def __init__(self, scene=None, port=9001):\n    \"\"\"Instantiate a ``VirtualScannerRunner``.\n\n    Parameters\n    ----------\n    scene : str, optional\n        Path to a Blender scene file to load.\n        Defaults to ``None``.\n    port : int, optional\n        The port to use to instantiate and communicate with the Flask server in Blender.\n        Defaults to ``9001``.\n    \"\"\"\n    self.subprocess = None\n    self.scene = scene\n    self.port = self._select_port(port)\n</code></pre>"},{"location":"reference/plantimager/vscan/#plantimager.vscan.VirtualScannerRunner.start","title":"<code>start()</code>","text":"<p>Start the Flask server in Blender.</p> Source code in <code>plantimager/vscan.py</code> <pre><code>def start(self):\n    \"\"\"Start the Flask server in Blender.\"\"\"\n    logger.info('Starting the Flask server in Blender...')\n    # Initialize the list of subprocess arguments:\n    proclist = [\"romi_virtualplantimager.py\", \"--\", \"--port\", str(self.port)]\n    # Add the scene file path to the list of subprocess arguments:\n    if self.scene is not None:\n        logger.debug(\"scene = %s\" % self.scene)\n        proclist.extend(['--scene', self.scene])\n    # Execute the subprocess as a child process:\n    self.subprocess = subprocess.Popen(proclist)\n    # Register the stop method to be executed upon normal subprocess termination\n    atexit.register(VirtualScannerRunner.stop, self)\n    # Wait for the Flask server to be ready...\n    while True:\n        try:\n            x = requests.get(\"http://localhost:%i\" % self.port)\n            break\n        except:\n            logger.debug(\"Virtual scanner not ready yet...\")\n            time.sleep(1)\n            continue\n    return\n</code></pre>"},{"location":"reference/plantimager/vscan/#plantimager.vscan.VirtualScannerRunner.stop","title":"<code>stop()</code>","text":"<p>Stop the Flask server in Blender.</p> Source code in <code>plantimager/vscan.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the Flask server in Blender.\"\"\"\n    logger.warning('Stopping the Flask server in Blender...')\n    # Get the 'Flask server' subprocess PID:\n    parent_pid = self.subprocess.pid\n    parent = psutil.Process(parent_pid)\n    # Recursively send SIGKILL signal to kill all children processes:\n    for child in parent.children(recursive=True):  # or parent.children() for recursive=False\n        child.kill()\n    # Send SIGKILL signal to kill 'Flask server' subprocess:\n    parent.kill()\n    # Check the subprocess has been killed:\n    while True:\n        # If the subprocess has been killed this will return something...\n        if self.subprocess.poll() is not None:\n            # See: https://docs.python.org/3/library/subprocess.html#subprocess.Popen.poll\n            break\n        time.sleep(1)\n    return\n</code></pre>"},{"location":"reference/plantimager/vscan/#plantimager.vscan.available_port","title":"<code>available_port(port)</code>","text":"<p>Test if it is possible to listen to this port for TCP/IPv4 connections.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>The localhost port to test.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if it's possible to listen on this port, <code>False</code> otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from plantimager.vscan import available_port\n&gt;&gt;&gt; available_port(9001)\nTrue\n</code></pre> Source code in <code>plantimager/vscan.py</code> <pre><code>def available_port(port):\n    \"\"\"Test if it is possible to listen to this port for TCP/IPv4 connections.\n\n    Parameters\n    ----------\n    port : int\n        The localhost port to test.\n\n    Returns\n    -------\n    bool\n        ``True`` if it's possible to listen on this port, ``False`` otherwise.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from plantimager.vscan import available_port\n    &gt;&gt;&gt; available_port(9001)\n    True\n\n    \"\"\"\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.bind(('127.0.0.1', port))\n        sock.listen(5)\n        sock.close()\n    except socket.error as e:\n        return False\n    return True\n</code></pre>"},{"location":"reference/plantimager/vscan/#plantimager.vscan.find_available_port","title":"<code>find_available_port(port_range)</code>","text":"<p>Find an available port.</p> <p>Parameters:</p> Name Type Description Default <code>port_range</code> <code>list of int</code> <p>A len-2 list of integers specifying the range of ports to test for availability.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The available port.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from plantimager.vscan import find_available_port\n&gt;&gt;&gt; find_available_port([9001, 9999])\n</code></pre> Source code in <code>plantimager/vscan.py</code> <pre><code>def find_available_port(port_range):\n    \"\"\"Find an available port.\n\n    Parameters\n    ----------\n    port_range : list of int\n        A len-2 list of integers specifying the range of ports to test for availability.\n\n    Returns\n    -------\n    int\n        The available port.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from plantimager.vscan import find_available_port\n    &gt;&gt;&gt; find_available_port([9001, 9999])\n\n    \"\"\"\n    port_range = range(*port_range)\n    rng = np.random.default_rng(5)\n    for port in rng.choice(port_range, size=len(port_range)):\n        if available_port(port):\n            break\n\n    return port\n</code></pre>"},{"location":"reference/plantimager/cli/","title":"cli","text":""},{"location":"reference/plantimager/cli/generate_dataset/","title":"generate_dataset","text":"<p>Created on Fri Dec  6 14:14:31 2019</p> <p>@author: alienor</p>"},{"location":"reference/plantimager/cli/hardware_robustness/","title":"hardware_robustness","text":""},{"location":"reference/plantimager/cli/hardware_robustness/#plantimager.cli.hardware_robustness.check_scan_configs","title":"<code>check_scan_configs(scans_list)</code>","text":"<p>Check the scan configuration is the same as the reference.</p> <p>Parameters:</p> Name Type Description Default <code>scans_list</code> <code>list of plantsb.FSDB.Scan</code> <p>List of <code>Scan</code> instances to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the scan configurations are the same, else <code>False</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import os, toml\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from plantdb.fsdb import FSDB\n&gt;&gt;&gt; db = FSDB(os.environ.get('ROMI_DB', '/home/aurele/Downloads/20221010_Jo/Scans/'))\n&gt;&gt;&gt; db.connect()  # print the list of scan dataset names\n&gt;&gt;&gt; check_scan_configs(db.get_scans())\n&gt;&gt;&gt; db.disconnect()\n</code></pre> Source code in <code>plantimager/cli/hardware_robustness.py</code> <pre><code>def check_scan_configs(scans_list):\n    \"\"\"Check the scan configuration is the same as the reference.\n\n    Parameters\n    ----------\n    scans_list : list of plantsb.FSDB.Scan\n        List of ``Scan`` instances to compare.\n\n    Returns\n    -------\n    bool\n        ``True`` if the scan configurations are the same, else ``False``.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import os, toml\n    &gt;&gt;&gt; from pathlib import Path\n    &gt;&gt;&gt; from plantdb.fsdb import FSDB\n    &gt;&gt;&gt; db = FSDB(os.environ.get('ROMI_DB', '/home/aurele/Downloads/20221010_Jo/Scans/'))\n    &gt;&gt;&gt; db.connect()  # print the list of scan dataset names\n    &gt;&gt;&gt; check_scan_configs(db.get_scans())\n    &gt;&gt;&gt; db.disconnect()\n\n    \"\"\"\n    same_cfg = True\n    ref_scan_cfg = {}\n\n    for scan in scans_list:\n        bak_cfg_file = Path(scan.path()) / \"scan.toml\"\n        if not bak_cfg_file.is_file():\n            logger.warning(f\"Could not load backup `scan.toml` for scan id '{scan.id}'!\")\n            continue\n        cfg = toml.load(str(bak_cfg_file))\n        scan_cfg = cfg['ScanPath']\n        if ref_scan_cfg == {}:\n            ref_scan_cfg = scan_cfg.deepcopy()\n        else:\n            same_type = compare_scan_type(ref_scan_cfg, scan_cfg)\n            same_params = compare_scan_params(ref_scan_cfg, scan_cfg)\n    return\n</code></pre>"},{"location":"reference/plantimager/cli/hardware_robustness/#plantimager.cli.hardware_robustness.make_animation","title":"<code>make_animation(db_location, imgs, img_fname, delay)</code>","text":"<p>Make the animation as a sequence of images taken at the same position.</p> <p>Parameters:</p> Name Type Description Default <code>db_location</code> <code>Path or str</code> <p>Path to the database directory.</p> required <code>imgs</code> <code>dict</code> <p><code>Scan.id</code> indexed dict of selected <code>img_fname</code></p> required <code>img_fname</code> <code>str</code> <p>Name (without extension) of the image (from the .</p> required <code>delay</code> <code>int</code> <p>The delay between successive frames</p> required Source code in <code>plantimager/cli/hardware_robustness.py</code> <pre><code>def make_animation(db_location, imgs, img_fname, delay):\n    \"\"\"Make the animation as a sequence of images taken at the same position.\n\n    Parameters\n    ----------\n    db_location : pathlib.Path or str\n       Path to the database directory.\n    imgs : dict\n        ``Scan.id`` indexed dict of selected `img_fname`\n    img_fname : str\n        Name (without extension) of the image (from the .\n    delay : int\n        The delay between successive frames\n\n    Returns\n    -------\n\n    \"\"\"\n    # Initialize a temporary directory use to store scan dataset before cleaning and running previous tasks to task to analyse:\n    tmp_dir = tempfile.mkdtemp()\n    # - Get the path of the temporary ROMI database\n    tmp_path = Path(tmp_dir)\n    logger.debug(f\"Create a temporary directory '{tmp_path}' to modify the images prior to animation...\")\n\n    # Copy the image to temporary directory:\n    annotated_imgs = {}\n    for n, (scan_id, img) in enumerate(imgs.items()):\n        img_fname = str(Path(img).stem) + f'_{n}' + '.jpg'\n        annotated_imgs[scan_id] = f\"{tmp_path}/{img_fname}\"\n        subprocess.run([\"cp\", img, annotated_imgs[scan_id]])\n\n    # Add the scan name to image\n    for scan_id, img in annotated_imgs.items():\n        cmd = ['mogrify', '-font', 'Liberation-Sans', '-fill', 'white', '-undercolor', \"black\", '-pointsize', '26',\n               '-gravity', 'NorthEast', '-annotate', '+10+10', f\"'{scan_id}/{img_fname}'\", img]\n        subprocess.run(cmd)\n\n    gif_fname = str(db_location / Path(str(Path(img_fname).stem) + '.gif'))\n    cmd = [\"convert\", \"-delay\", f\"{delay}\"] + sorted(map(str, annotated_imgs.values())) + [gif_fname]\n    subprocess.run(cmd, check=True)\n    rmtree(tmp_path)\n    logger.info(f\"Generated the GIF animation: '{gif_fname}'.\")\n</code></pre>"},{"location":"reference/plantimager/cli/hardware_robustness/#plantimager.cli.hardware_robustness.romi_run_task","title":"<code>romi_run_task(scan_path, task_name, cfg_file)</code>","text":"<p>Run configured pipeline for given task on a scan.</p> <p>Parameters:</p> Name Type Description Default <code>scan_path</code> <code>Path or str</code> <p>Path to the scan dataset directory.</p> required <code>task_name</code> <code>str</code> <p>Name of the ROMI task to run.</p> required <code>cfg_file</code> <code>str</code> <p>Path to the configuration file to use to run the pipeline (<code>romi_run_task</code>).</p> required Source code in <code>plantimager/cli/hardware_robustness.py</code> <pre><code>def romi_run_task(scan_path, task_name, cfg_file):\n    \"\"\"Run configured pipeline for given task on a scan.\n\n    Parameters\n    ----------\n    scan_path : pathlib.Path or str\n       Path to the scan dataset directory.\n    task_name : str\n        Name of the ROMI task to run.\n    cfg_file : str\n        Path to the configuration file to use to run the pipeline (``romi_run_task``).\n\n    \"\"\"\n    logger.info(f\"Executing task '{task_name}' on scan dataset '{str(scan_path)}'.\")\n    cmd = [\"romi_run_task\", task_name, str(scan_path), \"--config\", cfg_file, \"--local-scheduler\"]\n    subprocess.run(cmd, check=True)\n    return\n</code></pre>"},{"location":"reference/plantimager/cli/multi_scan/","title":"multi_scan","text":"<p>Multiple imaging with varying parameters to assess/test acquisition or reconstruction pipelines.</p>"},{"location":"reference/plantimager/cli/multi_scan/#plantimager.cli.multi_scan.load_config_from_directory","title":"<code>load_config_from_directory(path)</code>","text":"<p>Load TOML &amp; JSON configuration files from path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to where the configuration file(s) should be.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The configuration dictionary, if loaded from the files.</p> Notes <p>We exclude the backup files <code>SCAN_TOML</code> &amp; <code>PIPE_TOML</code> from the list of loadable files.</p> Source code in <code>plantimager/cli/multi_scan.py</code> <pre><code>def load_config_from_directory(path):\n    \"\"\"Load TOML &amp; JSON configuration files from path.\n\n    Parameters\n    ----------\n    path : str\n        Path to where the configuration file(s) should be.\n\n    Returns\n    -------\n    dict\n        The configuration dictionary, if loaded from the files.\n\n    Notes\n    -----\n    We exclude the backup files ``SCAN_TOML`` &amp; ``PIPE_TOML`` from the list of loadable files.\n\n    \"\"\"\n    # List TOML config files:\n    toml_list = glob.glob(os.path.join(path, \"*.toml\"))\n    toml_list = [cfg for cfg in toml_list if cfg.split(\"/\")[-1] not in (SCAN_TOML, PIPE_TOML)]\n    # List JSON config files:\n    json_list = glob.glob(os.path.join(path, \"*.json\"))\n\n    if len(toml_list) == 0 and len(json_list) == 0:\n        logger.critical(f\"Could not find any TOML or JSON configuration file in '{path}'!\")\n        sys.exit(\"Configuration file missing!\")\n\n    config = {}\n    # Read TOML configs\n    for f in toml_list:\n        try:\n            c = toml.load(open(f))\n            config = {**config, **c}\n        except:\n            logger.warning(f\"Could not process TOML config file: {f}\")\n        else:\n            logger.info(f\"Loaded configuration file: {f}\")\n    # Read JSON configs:\n    for f in json_list:\n        try:\n            c = json.load(open(f))\n            config = {**config, **c}\n        except:\n            logger.warning(f\"Could not process JSON config file: {f}\")\n        else:\n            logger.info(f\"Loaded configuration file: {f}\")\n\n    return config\n</code></pre>"},{"location":"reference/plantimager/cli/multi_scan/#plantimager.cli.multi_scan.load_config_from_file","title":"<code>load_config_from_file(path)</code>","text":"<p>Load TOML or JSON configuration file from path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the configuration file to load.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The configuration dictionary.</p> Source code in <code>plantimager/cli/multi_scan.py</code> <pre><code>def load_config_from_file(path):\n    \"\"\"Load TOML or JSON configuration file from path.\n\n    Parameters\n    ----------\n    path : str\n        Path to the configuration file to load.\n\n    Returns\n    -------\n    dict\n        The configuration dictionary.\n\n    \"\"\"\n    config = None\n    if path.endswith(\"toml\"):\n        try:\n            config = toml.load(open(path))\n        except:\n            logger.critical(f\"Could not load TOML configuration file '{path}'!\")\n    elif path.endswith(\"json\"):\n        try:\n            config = json.load(open(path))\n        except:\n            logger.critical(f\"Could not load JSON configuration file '{path}'!\")\n    else:\n        logger.critical(f\"Unsupported configuration file format, should be TOML or JSON!\")\n\n    if config is None:\n        sys.exit(f\"Error while loading configuration file!\")\n\n    return config\n</code></pre>"},{"location":"reference/plantimager/configs/","title":"configs","text":""},{"location":"reference/plantimager/configs/lpy/","title":"lpy","text":""},{"location":"reference/plantimager/configs/scan/","title":"scan","text":""},{"location":"reference/plantimager/tasks/","title":"tasks","text":""},{"location":"reference/plantimager/tasks/lpy/","title":"lpy","text":""},{"location":"reference/plantimager/tasks/lpy/#plantimager.tasks.lpy.VirtualPlant","title":"<code>VirtualPlant</code>","text":"<p>             Bases: <code>RomiTask</code></p> <p>Task generating a virtual plant from an LPY model.</p> <p>Attributes:</p> Name Type Description <code>upstream_task</code> <code>LpyFileset</code> <p>The fileset specific to LPY model.</p> <code>lpy_file_id</code> <code>Parameter</code> <p>Name of the LPY file used as model. Should exist in the <code>LpyFileset</code>.</p> <code>metadata</code> <code>list</code> <p>The list of metadata to export with the model. By default, ask for \"angles\" &amp; \"internodes\".</p> <code>lpy_globals</code> <code>dict</code> <p>Global LPY variables used by <code>lpy.Lsystem()</code> method. By default, set the \"SEED\" LPY variable to a random integer in <code>[0, 100000]</code>.</p>"},{"location":"reference/plantimager/tasks/lpy/#plantimager.tasks.lpy.VirtualPlant.run","title":"<code>run()</code>","text":"<p>Generates the virtual plant.</p> Source code in <code>plantimager/tasks/lpy.py</code> <pre><code>def run(self):\n    \"\"\"Generates the virtual plant.\"\"\"\n    from openalea import lpy\n    from openalea.plantgl import all\n\n    lpy_globals = json.loads(luigi.DictParameter().serialize(self.lpy_globals))\n\n    with tempfile.TemporaryDirectory() as tmpdir:\n        x = self.input().get().get_file(self.lpy_file_id)\n        tmp_filename = os.path.join(tmpdir, \"f.lpy\")\n        with open(tmp_filename, \"wb\") as f:\n            f.write(x.read_raw())\n\n        lsystem = lpy.Lsystem(tmp_filename, globals=lpy_globals)\n        for lstring in lsystem:\n            t = all.PglTurtle()\n            lsystem.turtle_interpretation(lstring, t)\n        scene = t.getScene()\n\n        output_file = self.output_file()\n        fname = os.path.join(tmpdir, \"plant.obj\")\n        scene.save(fname)\n        classes = luigi.DictParameter().serialize(VirtualPlantConfig().classes).replace(\" \", \"\")\n\n        logger.info(\"Splitting mesh by classes in Blender with `romi_split_by_material`...\")\n        subprocess.run([\"romi_split_by_material.py\", \"--\", \"--classes\", classes, fname, fname], check=True)\n\n        logger.info(\"Cleaning mesh in Blender with `romi_clean_mesh`...\")\n        subprocess.run([\"romi_clean_mesh.py\", \"--\", fname, fname], check=True)\n\n        output_file.import_file(fname)\n        output_mtl_file = self.output().get().create_file(output_file.id + \"_mtl\")\n        output_mtl_file.import_file(fname.replace(\"obj\", \"mtl\"))\n\n    # -- UGLY HACK --\n    # We need to replace the MTL file name referenced in OBJ file!\n    # The OBJ file is originally saved as a temporary file named 'plant.obj' by `scene.save(fname)`\n    # The associated MTL (material) file is thus named 'plant.mtl'...\n    # We thus edit the `output_file` OBJ file to match the renaming done by `output_mtl_file.import_file()`\n    # ---------------\n    # - Load the OBJ to edit:\n    with open(output_file.path(), \"r\") as f:\n        obj_lines = f.readlines()\n        # It seems that there is only one ref to the 'plant.mtl' file but, just in case, we check all lines...\n        fixed_obj_lines = [re.sub('plant.mtl', f'{output_mtl_file.id}.mtl', line) for line in obj_lines]\n    # - Save the fixed version:\n    with open(output_file.path(), \"w\") as f:\n        f.writelines(fixed_obj_lines)\n\n    # - Export 'angles' and 'internodes' as metadata of the OBJ file:\n    measures = {}\n    for m in self.metadata:\n        m_val = lsystem.context().globals()[m]\n        if m in [\"angles\", \"internodes\"]:\n            measures[m] = m_val\n        output_file.set_metadata(m, m_val)\n\n    # - Export 'angles' and 'internodes' to a 'measures.json' file (to match manual measurements method):\n    from plantdb.fsdb import _scan_measures_path\n    measures_json = _scan_measures_path(output_file.get_scan())\n    with open(measures_json, 'w') as f:\n        f.write(json.dumps(measures, indent=4))\n</code></pre>"},{"location":"reference/plantimager/tasks/scan/","title":"scan","text":""},{"location":"reference/plantimager/tasks/scan/#plantimager.tasks.scan.CalibrationScan","title":"<code>CalibrationScan</code>","text":"<p>             Bases: <code>Scan</code></p> <p>A task for running a scan, real or virtual, with a calibration path.</p> <p>Module: romiscan.tasks.scan Colmap poses for subsequent scans. (TODO: see calibration documentation) Default upstream tasks: None</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>DictParameter</code> <p>metadata for the scan</p> required <code>scanner</code> <code>DictParameter</code> <p>scanner hardware configuration (TODO: see hardware documentation)</p> required <code>path</code> <code>DictParameter</code> <p>scanner path configuration (TODO: see hardware documentation)</p> required <code>n_points_line</code> <code>IntParameter</code> <p>Number of shots taken on the orthogonal calibration lines. Defaults to <code>10</code>.</p> required <code>offset</code> <code>IntParameter</code> <p>Offset to axis limits, in millimeters. Defaults to <code>5</code>.</p> required"},{"location":"reference/plantimager/tasks/scan/#plantimager.tasks.scan.CalibrationScan.run","title":"<code>run()</code>","text":"<p>Run the calibration scan.</p> Notes <p>Overrides the method from <code>Scan</code>.</p> Source code in <code>plantimager/tasks/scan.py</code> <pre><code>def run(self):\n    \"\"\"Run the calibration scan.\n\n    Notes\n    -----\n    Overrides the method from ``Scan``.\n    \"\"\"\n    path = Scan().get_path()\n    # Load the Scanner instance to get axes limits:\n    scanner = Scan().load_scanner()\n    # Get axes limits:\n    x_lims = getattr(scanner.cnc, 'x_lims', None)\n    if x_lims is not None:\n        logger.info(f\"Got X limits from scanner: {x_lims}\")\n        # Avoid true limits, as you might get stuck in some cases:\n        x_lims = [x_lims[0] + self.offset, x_lims[1] - self.offset]\n    y_lims = getattr(scanner.cnc, 'y_lims', None)\n    if y_lims is not None:\n        logger.info(f\"Got Y limits from scanner: {y_lims}\")\n        # Avoid true limits, as you might get stuck in some cases:\n        y_lims = [y_lims[0] + self.offset, y_lims[1] - self.offset]\n    # Get the ScanPath module:\n    path_module = importlib.import_module(ScanPath().module)\n    # Create a CalibrationPath instance:\n    calibration_path = getattr(path_module, \"CalibrationPath\")(path, self.n_points_line,\n                                                               x_lims=x_lims, y_lims=y_lims)\n    # Run the calibration procedure:\n    Scan().run(path=calibration_path, scanner=scanner)\n</code></pre>"},{"location":"reference/plantimager/tasks/scan/#plantimager.tasks.scan.HdriFileset","title":"<code>HdriFileset</code>","text":"<p>             Bases: <code>FilesetExists</code></p> <p>This task check the existence of a <code>'hdri'</code> Fileset.</p> <p>Attributes:</p> Name Type Description <code>upstream_task</code> <code>None</code> <p>No upstream task is required.</p> <code>scan_id</code> <code>Parameter</code> <p>The id of the scan dataset that should contain the fileset.</p> <code>fileset_id</code> <code>str</code> <p>The name of the fileset that should exist.</p>"},{"location":"reference/plantimager/tasks/scan/#plantimager.tasks.scan.IntrinsicCalibrationScan","title":"<code>IntrinsicCalibrationScan</code>","text":"<p>             Bases: <code>Scan</code></p> <p>A task to calibrate the intrinsic parameters of the camera.</p> <p>Parameters:</p> Name Type Description Default <code>n_poses</code> <code>IntParameter</code> <p>Number of calibration pattern pictures to take. Defaults to <code>20</code>.</p> required <code>offset</code> <code>IntParameter</code> <p>Offset to axis limits, in millimeters. Defaults to <code>5</code>.</p> required <code>romi_run_task</code> required"},{"location":"reference/plantimager/tasks/scan/#plantimager.tasks.scan.ObjFileset","title":"<code>ObjFileset</code>","text":"<p>             Bases: <code>FilesetExists</code></p> <p>This task check the existence of a <code>'data'</code> Fileset.</p> <p>Attributes:</p> Name Type Description <code>upstream_task</code> <code>None</code> <p>No upstream task is required.</p> <code>scan_id</code> <code>Parameter</code> <p>The id of the scan dataset that should contain the fileset.</p> <code>fileset_id</code> <code>str</code> <p>The name of the fileset that should exist.</p>"},{"location":"reference/plantimager/tasks/scan/#plantimager.tasks.scan.PaletteFileset","title":"<code>PaletteFileset</code>","text":"<p>             Bases: <code>FilesetExists</code></p> <p>This task check the existence of a <code>'palette'</code> Fileset.</p> <p>Attributes:</p> Name Type Description <code>upstream_task</code> <code>None</code> <p>No upstream task is required.</p> <code>scan_id</code> <code>Parameter</code> <p>The id of the scan dataset that should contain the fileset.</p> <code>fileset_id</code> <code>str</code> <p>The name of the fileset that should exist.</p>"},{"location":"reference/plantimager/tasks/scan/#plantimager.tasks.scan.Scan","title":"<code>Scan</code>","text":"<p>             Bases: <code>RomiTask</code></p> <p>A task for running a scan, real or virtual.</p> <p>Module: romiscan.tasks.scan Default upstream tasks: None</p> <p>Attributes:</p> Name Type Description <code>upstream_task</code> <code>None</code> <p>No upstream task is required by a <code>Scan</code> task.</p> <code>scan_id</code> <code>(Parameter, optional)</code> <p>The scan id to use to create the <code>FilesetTarget</code>.</p> <code>metadata</code> <code>(DictParameter, optional)</code> <p>Metadata of the scan. Defaults to an empty dictionary.</p> <code>scanner</code> <code>(DictParameter, optional)</code> <p>Scanner configuration to use for this task. (TODO: see hardware documentation) Defaults to an empty dictionary.</p>"},{"location":"reference/plantimager/tasks/scan/#plantimager.tasks.scan.Scan.get_path","title":"<code>get_path()</code>","text":"<p>Load the <code>ScanPath</code> module &amp; get the configuration from the TOML config file.</p> Source code in <code>plantimager/tasks/scan.py</code> <pre><code>def get_path(self) -&gt; path.Path:\n    \"\"\"Load the ``ScanPath`` module &amp; get the configuration from the TOML config file.\"\"\"\n    path_module = importlib.import_module(ScanPath().module)\n    path = getattr(path_module, ScanPath().class_name)(**ScanPath().kwargs)\n    return path\n</code></pre>"},{"location":"reference/plantimager/tasks/scan/#plantimager.tasks.scan.Scan.load_scanner","title":"<code>load_scanner()</code>","text":"<p>Load the <code>CNC</code>, <code>Gimbal</code> &amp; <code>Camera</code> modules and create a <code>Scanner</code> instance.</p> Source code in <code>plantimager/tasks/scan.py</code> <pre><code>def load_scanner(self) -&gt; Scanner:\n    \"\"\"Load the ``CNC``, ``Gimbal`` &amp; ``Camera`` modules and create a ``Scanner`` instance.\"\"\"\n    scanner_config = self.scanner\n\n    # - Load the CNC configuration from TOML:\n    cnc_module = scanner_config[\"cnc\"][\"module\"]\n    logger.debug(f\"CNC module: {cnc_module}\")\n    cnc_kwargs = scanner_config[\"cnc\"][\"kwargs\"]\n    param_str = [f\"\\n  - {k}={v}\" for k, v in cnc_kwargs.items()]\n    logger.debug(f\"CNC parameters: {''.join(param_str)}\")\n    # - Import corresponding module to python:\n    cnc_module = importlib.import_module(cnc_module)\n    cnc = getattr(cnc_module, \"CNC\")(**cnc_kwargs)\n\n    # - Load the Gimbal configuration from TOML:\n    gimbal_module = scanner_config[\"gimbal\"][\"module\"]\n    gimbal_kwargs = scanner_config[\"gimbal\"][\"kwargs\"]\n    logger.debug(f\"Gimbal module: {gimbal_module}\")\n    param_str = [f\"\\n  - {k}={v}\" for k, v in gimbal_kwargs.items()]\n    logger.debug(f\"Gimbal parameters: {''.join(param_str)}\")\n    # - Import corresponding module to python:\n    gimbal_module = importlib.import_module(gimbal_module)\n    gimbal = getattr(gimbal_module, \"Gimbal\")(**gimbal_kwargs)\n\n    # - Load the Camera configuration from TOML:\n    camera_module = scanner_config[\"camera\"][\"module\"]\n    camera_kwargs = scanner_config[\"camera\"][\"kwargs\"]\n    logger.debug(f\"Camera module: {camera_module}\")\n    param_str = [f\"\\n  - {k}={v}\" for k, v in camera_kwargs.items()]\n    logger.debug(f\"Camera parameters: {''.join(param_str)}\")\n    # - Import corresponding module to python:\n    camera_module = importlib.import_module(camera_module)\n    camera = getattr(camera_module, \"Camera\")(**camera_kwargs)\n\n    return Scanner(cnc, gimbal, camera)\n</code></pre>"},{"location":"reference/plantimager/tasks/scan/#plantimager.tasks.scan.Scan.output","title":"<code>output()</code>","text":"<p>The output fileset associated to a <code>Scan</code> task is an 'images' dataset.</p> Source code in <code>plantimager/tasks/scan.py</code> <pre><code>def output(self):\n    \"\"\"The output fileset associated to a ``Scan`` task is an 'images' dataset.\"\"\"\n    return FilesetTarget(DatabaseConfig().scan, \"images\")\n</code></pre>"},{"location":"reference/plantimager/tasks/scan/#plantimager.tasks.scan.Scan.requires","title":"<code>requires()</code>","text":"<p>Nothing is required.</p> Source code in <code>plantimager/tasks/scan.py</code> <pre><code>def requires(self):\n    \"\"\"Nothing is required.\"\"\"\n    return []\n</code></pre>"},{"location":"reference/plantimager/tasks/scan/#plantimager.tasks.scan.Scan.run","title":"<code>run(path=None, scanner=None, extra_md=None)</code>","text":"<p>Run a scan.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>If <code>None</code> (default), load the <code>ScanPath</code> module &amp; get the configuration from the TOML config file. Else should be a <code>plantimager.path.Path</code> instance.</p> <code>None</code> <code>scanner</code> <code>Scanner or VirtualScanner</code> <p>If <code>None</code> (default), load the configuration from the TOML config file with <code>self.load_scanner</code>. Else should be a <code>Scanner</code> or <code>VirtualScanner</code> instance.</p> <code>None</code> <code>extra_md</code> <code>dict</code> <p>A dictionary of extra metadata to add to the 'images' fileset.</p> <code>None</code> Source code in <code>plantimager/tasks/scan.py</code> <pre><code>def run(self, path=None, scanner=None, extra_md=None):\n    \"\"\"Run a scan.\n\n    Parameters\n    ----------\n    path : plantimager.path.Path, optional\n        If ``None`` (default), load the ``ScanPath`` module &amp; get the configuration from the TOML config file.\n        Else should be a ``plantimager.path.Path`` instance.\n    scanner : plantimager.scanner.Scanner or plantimager.scanner.VirtualScanner, optional\n        If ``None`` (default), load the configuration from the TOML config file with `self.load_scanner`.\n        Else should be a ``Scanner`` or ``VirtualScanner`` instance.\n    extra_md : dict, optional\n        A dictionary of extra metadata to add to the 'images' fileset.\n\n    \"\"\"\n    if path is None:\n        path = self.get_path()\n    if scanner is None:\n        scanner = self.load_scanner()\n\n    metadata = json.loads(luigi.DictParameter().serialize(self.metadata))\n    # Import the axes limits from the ``plantimager.scanner.Scanner`` instance &amp; add them to the \"hardware\" metadata\n    if \"hardware\" not in metadata:\n        logger.warning(\"Metadata entry 'hardware' is missing from the configuration file!\")\n        metadata[\"hardware\"] = {}\n\n    if isinstance(scanner, Scanner):\n        metadata[\"hardware\"]['x_lims'] = getattr(scanner.cnc, \"x_lims\", None)\n        metadata[\"hardware\"]['y_lims'] = getattr(scanner.cnc, \"y_lims\", None)\n        metadata[\"hardware\"]['z_lims'] = getattr(scanner.cnc, \"z_lims\", None)\n\n    # Add the extra metadata to the metadata:\n    if extra_md is not None:\n        metadata.update(extra_md)\n    # Add the acquisition time to the metadata:\n    from plantimager.utils import now\n    metadata[\"acquisition_date\"] = now()\n\n    # Get (create) the output 'images' fileset:\n    output_fileset = self.output().get()\n    # Scan with the plant imager:\n    scanner.scan(path, output_fileset)\n    if isinstance(scanner, Scanner):\n        # Go back close to home position:\n        scanner.cnc.moveto(10., 10., 10.)\n\n    # Write the metadata to the JSON associated to the 'images' fileset:\n    output_fileset.set_metadata(metadata)\n    # TODO: Remove (duplicate) metadata from 'images' fileset in later release!\n    # Write the metadata to the JSON associated to the scan dataset:\n    output_fileset.scan.set_metadata(metadata)\n    # Add a description of the type of scan data with a \"channel\" entry in the 'images' fileset metadata:\n    output_fileset.set_metadata(\"channels\", scanner.channels())\n    return\n</code></pre>"},{"location":"reference/plantimager/tasks/scan/#plantimager.tasks.scan.ScannerToCenter","title":"<code>ScannerToCenter</code>","text":"<p>             Bases: <code>RomiTask</code></p> <p>A task to move the camera at the center of the path.</p> <p>Attributes:</p> Name Type Description <code>upstream_task</code> <code>None</code> <p>No upstream task is required.</p> <code>scan_id</code> <code>(Parameter, optional)</code> <p>The scan id to use to get or create the <code>FilesetTarget</code>.</p>"},{"location":"reference/plantimager/tasks/scan/#plantimager.tasks.scan.SceneFileset","title":"<code>SceneFileset</code>","text":"<p>             Bases: <code>FilesetExists</code></p> <p>This task check the existence of a <code>'scenes'</code> Fileset.</p> <p>Attributes:</p> Name Type Description <code>upstream_task</code> <code>None</code> <p>No upstream task is required.</p> <code>scan_id</code> <code>Parameter</code> <p>The id of the scan dataset that should contain the fileset.</p> <code>fileset_id</code> <code>str</code> <p>The name of the fileset that should exist.</p>"},{"location":"reference/plantimager/tasks/scan/#plantimager.tasks.scan.VirtualScan","title":"<code>VirtualScan</code>","text":"<p>             Bases: <code>Scan</code></p> <p>Task to create scans of virtual plants using Blender.</p> <p>Attributes:</p> Name Type Description <code>upstream_task</code> <code>None</code> <p>No upstream task is required by a <code>VirtualScan</code> task.</p> <code>scan_id</code> <code>(Parameter, optional)</code> <p>The scan id to use to create the <code>FilesetTarget</code>.</p> <code>metadata</code> <code>(DictParameter, optional)</code> <p>Metadata of the scan. Defaults to an empty dictionary.</p> <code>scanner</code> <code>(DictParameter, optional)</code> <p>VirtualScanner configuration to use for this task. Defaults to an empty dictionary.</p> <code>load_scene</code> <code>(BoolParameter, optional)</code> <p>Whether to load the scene file. Defaults to <code>False</code>.</p> <code>scene_file_id</code> <code>(Parameter, optional)</code> <p>The name of the scene file to load, if any. Defaults to an empty string.</p> <code>use_palette</code> <code>(BoolParameter, optional)</code> <p>Whether to use a color palette to rendre the virtual plant. Defaults to <code>False</code>.</p> <code>use_hdri</code> <code>(BoolParameter, optional)</code> <p>Whether to use an HDRI file for the background. Defaults to <code>False</code>.</p> <code>obj_fileset</code> <code>(TaskParameter, optional)</code> <p>The Fileset that contains the virtual plant OBJ file to render and capture. Defaults to <code>VirtualPlant</code>.</p> <code>hdri_fileset</code> <code>(TaskParameter, optional)</code> <p>The Fileset that contains the HDRI files to use as background. Defaults to <code>HdriFileset</code>.</p> <code>scene_fileset</code> <code>(TaskParameter, optional)</code> <p>The Fileset that contain the scenes to use. Defaults to <code>SceneFileset</code>.</p> <code>palette_fileset</code> <code>(TaskParameter, optional)</code> <p>The Fileset that contains the color palette to use to render the virtual plant. Defaults to <code>PaletteFileset</code>.</p> <code>render_ground_truth</code> <code>(BoolParameter, optional)</code> <p>If <code>True</code>, create the mask image for defined ground truth classes in virtual plant model. Defaults to <code>False</code>.</p> <code>colorize</code> <code>(bool, optional)</code> <p>Whether the virtual plant should be colorized in Blender. Defaults to <code>True</code>.</p>"},{"location":"reference/plantimager/tasks/scan/#plantimager.tasks.scan.VirtualScan.load_scanner","title":"<code>load_scanner()</code>","text":"<p>Create the virtual scanner configuration and defines the files it.</p> <p>Returns:</p> Type Description <code>VirtualScanner</code> <p>The configured virtual scanner.</p> Notes <p>Overrides the method from <code>Scan</code>.</p> Source code in <code>plantimager/tasks/scan.py</code> <pre><code>def load_scanner(self):\n    \"\"\"Create the virtual scanner configuration and defines the files it.\n\n    Returns\n    -------\n    plantimager.vscan.VirtualScanner\n        The configured virtual scanner.\n\n    Notes\n    -----\n    Overrides the method from ``Scan``.\n    \"\"\"\n    # - Create the virtual scanner configuration (from TOML section 'VirtualScan.scanner'):\n    scanner_config = json.loads(luigi.DictParameter().serialize(self.scanner))\n\n    # - Defines the virtual plant files:\n    # Get the `Fileset` containing the OBJ &amp; MTL files:\n    obj_fileset = self.input()[\"object\"].get()\n    # Get the OBJ `File`:\n    while True:\n        # Randomly pick one of the files from the fileset...\n        obj_file = random.choice(obj_fileset.get_files())\n        if \"obj\" in obj_file.filename:\n            # ...stop when \"obj\" is found in the filename\n            break\n    # Get the MTL `File`:\n    try:\n        mtl_file = obj_fileset.get_file(obj_file.id + \"_mtl\")\n    except:\n        mtl_file = None\n\n    # - Defines the palette `File`, if requested:\n    palette_file = None\n    if self.use_palette:\n        # Randomly choose among existing palette files:\n        palette_fileset = self.input()[\"palette\"].get()\n        palette_file = random.choice(palette_fileset.get_files())\n\n    # - Defines the hdri `File`, if requested:\n    hdri_file = None\n    if self.use_hdri:\n        # Randomly choose among existing hdri files:\n        hdri_fileset = self.input()[\"hdri\"].get()\n        hdri_file = random.choice(hdri_fileset.get_files())\n\n    # - Defines the scene `File`, if requested:\n    if self.load_scene:\n        scene_fileset = self.input()[\"scene\"].get()\n        # Duplicate all files in a temporary directory: (TODO: why?!)\n        self.tmpdir = io.tmpdir_from_fileset(scene_fileset)\n        # Use the selected `scene_file_id` to get the `File`:\n        scene_file = scene_fileset.get_file(self.scene_file_id).filename\n        # Add its path to the virtual scanner config to create:\n        scanner_config[\"scene\"] = os.path.join(self.tmpdir.name, scene_file)\n\n    # - Defines the list of classes to create ground-truth images for, if requested:\n    if self.render_ground_truth:\n        # Add the list of classes names to the virtual scanner config to create:\n        scanner_config[\"classes\"] = list(VirtualPlantConfig().classes.values())\n\n    # - Instantiate the `VirtualScanner` using the config:\n    vscan = VirtualScanner(**scanner_config)\n    # - Load the defined OBJ, MTL and palette files to Blender:\n    vscan.load_object(obj_file, mtl=mtl_file, palette=palette_file, colorize=self.colorize)\n    # - Load the HDRI files to Blender, if requested:\n    if self.use_hdri:\n        vscan.load_background(hdri_file)\n    # Get the bounding-box from Blender &amp; add it to the output fileset metadata:\n    bbox = vscan.get_bounding_box()\n    self.output().get().set_metadata(\"bounding_box\", bbox)\n\n    return vscan\n</code></pre>"},{"location":"reference/plantimager/tasks/scan/#plantimager.tasks.scan.VirtualScan.requires","title":"<code>requires()</code>","text":"<p>Defines the <code>VirtualScan</code> task requirements.</p> <p>Always require a <code>Fileset</code> that contains a virtual plant. It can be an <code>ObjFileset</code> or the output of the <code>VirtualPlant</code> task. If the use of an HDRI is required, check the <code>HdriFileset</code> exists. If the use of a color palette is required, check the <code>PaletteFileset</code> exists. If the use of a scene is required, check the <code>SceneFileset</code> exists.</p> Notes <p>Overrides the method from <code>Scan</code>.</p> Source code in <code>plantimager/tasks/scan.py</code> <pre><code>def requires(self):\n    \"\"\"Defines the ``VirtualScan`` task requirements.\n\n    Always require a `Fileset` that contains a virtual plant.\n    It can be an ``ObjFileset`` or the output of the ``VirtualPlant`` task.\n    If the use of an HDRI is required, check the ``HdriFileset`` exists.\n    If the use of a color palette is required, check the ``PaletteFileset`` exists.\n    If the use of a scene is required, check the ``SceneFileset`` exists.\n\n    Notes\n    -----\n    Overrides the method from ``Scan``.\n    \"\"\"\n    requires = {\n        \"object\": self.obj_fileset()\n    }\n    if self.use_hdri:\n        requires[\"hdri\"] = self.hdri_fileset()\n    if self.use_palette:\n        requires[\"palette\"] = self.palette_fileset()\n    if self.load_scene:\n        requires[\"scene\"] = self.scene_fileset()\n    return requires\n</code></pre>"}]}